<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ComicCore - Pro Creator</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">

<!-- GIF encoder for export -->
<script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Bangers&family=Comic+Neue:wght@400;700&family=Kalam:wght@700&family=Permanent+Marker&family=Creepster&family=Luckiest+Guy&family=Orbitron:wght@900&family=Rock+Salt&family=Special+Elite&family=Fredoka+One&family=Boogaloo&family=Anton&family=Chewy&family=Gloria+Hallelujah&family=Mountains+of+Christmas&family=Shadows+Into+Light&family=Press+Start+2P&family=Caveat:wght@700&family=Bungee+Inline&family=Righteous&family=Fascinate&family=Pacifico&family=Abril+Fatface&family=Lilita+One&family=Audiowide&family=Russo+One&family=Black+Ops+One&family=Satisfy&family=Dancing+Script:wght@700&family=Bebas+Neue&family=Alfa+Slab+One&display=swap" rel="stylesheet">

<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
    
    :root { 
        --bg: #0f0f11; --card: #1c1c1e; --text: #f5f5f7; 
        --accent: #ff7a00; --border: #2c2c2e; --teal: #00d2ff; 
        --danger: #ff3b30;
    }

    body { 
        margin: 0; font-family: 'Inter', sans-serif; background: var(--bg); 
        color: var(--text); overflow: hidden; display: flex; flex-direction: column; height: 100vh; 
    }

    /* --- UI Components --- */
    .toolbar-top { 
        padding: 12px 16px; display: flex; justify-content: space-between; 
        align-items: center; background: var(--card); border-bottom: 1px solid var(--border); 
        z-index: 2000; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }

    .nav-btn { 
        background: #2c2c2e; border: 1px solid var(--border); color: white; 
        padding: 8px 14px; border-radius: 8px; cursor: pointer; 
        font-size: 12px; font-weight: 700; transition: 0.2s;
        display: flex; align-items: center; gap: 6px;
    }
    .nav-btn:hover { background: #3a3a3c; border-color: #48484a; }

    #frame-drawer { 
        position: absolute; top: -180px; left: 0; width: 100%; height: 170px; 
        background: #000; border-bottom: 2px solid var(--accent); 
        display: flex; flex-direction: column; gap: 8px; padding: 12px; 
        transition: 0.4s cubic-bezier(0.4, 0, 0.2, 1); z-index: 1900; box-sizing: border-box;
    }
    #frame-drawer.open { top: 60px; }
    
    .drawer-row { display: flex; gap: 12px; overflow-x: auto; align-items: center; padding-bottom: 5px; }
    .frame-thumb { 
        min-width: 90px; height: 70px; background: #222; border: 2px solid transparent; 
        border-radius: 8px; cursor: pointer; display: flex; align-items: center; 
        justify-content: center; font-size: 11px; flex-shrink: 0; font-weight: 900; 
        background-size: cover; background-position: center; transition: 0.2s;
    }
    .frame-thumb.active { border-color: var(--accent); background: #333; transform: scale(1.05); }

    #viewport { 
        flex: 1; display: flex; justify-content: center; align-items: center; 
        background: #050505; position: relative; overflow: hidden; padding: 60px;
        cursor: default;
    }
    #viewport.panning { cursor: grabbing; }
    #canvas-container {
        position: relative; display: inline-block;
        transform-origin: center center;
        will-change: transform;
        transition: none;
    }
    /* Zoom level indicator */
    #zoom-hud {
        position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.65); color: #fff; font-size: 11px; font-weight: 800;
        padding: 4px 12px; border-radius: 8px; pointer-events: none;
        opacity: 0; transition: opacity 0.3s; letter-spacing: 0.5px; z-index: 1000;
        display: flex; align-items: center; gap: 8px;
    }
    #zoom-hud.visible { opacity: 1; }
    #zoom-hud button {
        pointer-events: all; background: rgba(255,255,255,0.15); border: none;
        color: #fff; font-size: 10px; font-weight: 900; padding: 2px 6px;
        border-radius: 4px; cursor: pointer; font-family: inherit;
    }
    #zoom-hud button:hover { background: rgba(255,255,255,0.3); }
    #comic-frame { 
        width: 600px; height: 600px; background: #fff; position: relative; 
        overflow: hidden; box-shadow: 0 10px 40px rgba(0,0,0,0.6); 
        background-size: cover; background-position: center;
    }

    #onion-skin-canvas {
        position: absolute; inset: 0; pointer-events: none; z-index: 5;
        display: none;
    }

    /* Dedicated background layer ‚Äî filter applied here, NOT on canvas root */
    #cc-bg-layer {
        position: absolute; inset: 0; z-index: 0;
        pointer-events: none; overflow: hidden;
    }
    #cc-bg-layer img.bg-gif {
        position: absolute; inset: 0; width: 100%; height: 100%;
        object-fit: cover; pointer-events: none;
        transform-origin: center center;
    }

    /* Drag-to-pan overlay ‚Äî transparent so bg is fully visible while dragging */
    #bg-drag-overlay {
        position: absolute; inset: 0; z-index: 200;
        cursor: grab; display: none;
        background: transparent;
        border: 2px dashed rgba(0,180,255,0.45);
        box-sizing: border-box;
    }
    #bg-drag-overlay.dragging { cursor: grabbing; }
    #bg-drag-overlay .drag-hint {
        position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.72); color: #00b4ff; font-size: 11px;
        font-weight: 900; padding: 5px 14px; border-radius: 20px;
        pointer-events: none; letter-spacing: 0.5px; white-space: nowrap;
        opacity: 0.9; transition: opacity 0.3s;
    }

    .layer { position: absolute; cursor: move; user-select: none; transform-origin: center; touch-action: none; z-index: 10; }
    .layer.active { outline: 3px solid var(--accent); outline-offset: 2px; z-index: 99 !important; }
    
    /* ‚îÄ‚îÄ Bubble System ‚îÄ‚îÄ */
    .speech-bubble {
        padding: 14px 18px; background: #fff; color: #000; font-weight: 800;
        text-align: center; min-width: 60px; position: relative;
        word-wrap: break-word; line-height: 1.35;
    }

    /* ‚îÄ‚îÄ Style 1: Classic Round (default speech) ‚îÄ‚îÄ */
    .bubble-style-round {
        border: 3.5px solid #000; border-radius: 999px;
        box-shadow: 3px 3px 0 #000;
    }
    .bubble-style-round .bubble-tail {
        position: absolute; bottom: -20px; left: 28px;
        width: 0; height: 0;
        border-left: 12px solid transparent;
        border-right: 4px solid transparent;
        border-top: 20px solid #000;
    }
    .bubble-style-round .bubble-tail::after {
        content: ''; position: absolute; top: -19px; left: -9px;
        width: 0; height: 0;
        border-left: 8px solid transparent;
        border-right: 2px solid transparent;
        border-top: 16px solid #fff;
    }

    /* ‚îÄ‚îÄ Style 2: Rounded Rect (modern chat) ‚îÄ‚îÄ */
    .bubble-style-chat {
        border: 3px solid #000; border-radius: 18px;
        box-shadow: 3px 3px 0 #000;
    }
    .bubble-style-chat .bubble-tail {
        position: absolute; bottom: -18px; right: 24px;
        width: 0; height: 0;
        border-left: 14px solid transparent;
        border-right: 0px solid transparent;
        border-top: 18px solid #000;
    }
    .bubble-style-chat .bubble-tail::after {
        content: ''; position: absolute; top: -17px; left: -11px;
        width: 0; height: 0;
        border-left: 10px solid transparent;
        border-top: 14px solid #fff;
    }

    /* ‚îÄ‚îÄ Style 3: Sharp Rectangle ‚îÄ‚îÄ */
    .bubble-style-rect {
        border: 3px solid #000; border-radius: 4px;
        box-shadow: 4px 4px 0 #000;
    }
    .bubble-style-rect .bubble-tail {
        position: absolute; bottom: -18px; left: 50%; transform: translateX(-50%);
        width: 0; height: 0;
        border-left: 12px solid transparent;
        border-right: 12px solid transparent;
        border-top: 18px solid #000;
    }
    .bubble-style-rect .bubble-tail::after {
        content: ''; position: absolute; top: -17px; left: -9px;
        width: 0; height: 0;
        border-left: 9px solid transparent;
        border-right: 9px solid transparent;
        border-top: 14px solid #fff;
    }

    /* ‚îÄ‚îÄ Style 4: Explosion / Spiky ‚îÄ‚îÄ */
    .bubble-style-spiky {
        border: 3px solid #000;
        clip-path: polygon(
            50% 0%, 61% 6%, 74% 2%, 79% 13%, 93% 12%,
            91% 25%, 100% 33%, 90% 41%, 98% 52%,
            86% 56%, 90% 70%, 76% 70%, 75% 84%,
            62% 79%, 54% 92%, 43% 83%, 30% 88%,
            28% 74%, 15% 76%, 17% 61%, 4% 56%,
            13% 45%, 3% 35%, 14% 27%, 8% 14%,
            22% 14%, 25% 2%, 38% 7%
        );
        padding: 22px 28px;
        box-shadow: none;
    }
    .bubble-style-spiky .bubble-tail { display: none; }

    /* ‚îÄ‚îÄ Style 5: Cloud (thinking) ‚îÄ‚îÄ */
    .bubble-style-cloud {
        border: 3px solid #000; border-radius: 50px;
        box-shadow: 3px 3px 0 #000;
        position: relative;
    }
    .bubble-style-cloud::before,
    .bubble-style-cloud::after {
        content: ''; position: absolute;
        background: #fff; border: 3px solid #000; border-radius: 50%;
    }
    .bubble-style-cloud::before { width: 40%; height: 55%; top: -28%; left: 15%; }
    .bubble-style-cloud::after  { width: 30%; height: 45%; top: -22%; right: 18%; }
    .bubble-style-cloud .bubble-tail { display: none; }
    .thought-dot-1, .thought-dot-2, .thought-dot-3 {
        position: absolute; background: #fff; border: 3px solid #000; border-radius: 50%;
    }
    .thought-dot-1 { width: 14px; height: 14px; bottom: -22px; left: 28px; }
    .thought-dot-2 { width: 9px;  height: 9px;  bottom: -34px; left: 22px; }
    .thought-dot-3 { width: 5px;  height: 5px;  bottom: -42px; left: 17px; }

    /* ‚îÄ‚îÄ Style 6: Jagged / Shout ‚îÄ‚îÄ */
    .bubble-style-shout {
        background: #ffeb3b; border: 3.5px solid #000;
        clip-path: polygon(
            5% 10%, 20% 0%, 35% 10%, 50% 0%, 65% 10%, 80% 0%, 95% 10%,
            100% 30%, 95% 50%, 100% 70%, 95% 90%,
            80% 100%, 65% 90%, 50% 100%, 35% 90%, 20% 100%, 5% 90%,
            0% 70%, 5% 50%, 0% 30%
        );
        padding: 20px 24px;
        box-shadow: none;
    }
    .bubble-style-shout .bubble-tail { display: none; }

    /* ‚îÄ‚îÄ Style 7: Whisper (dashed oval) ‚îÄ‚îÄ */
    .bubble-style-whisper {
        border: 3px dashed #000; border-radius: 999px;
        background: rgba(255,255,255,0.92);
        box-shadow: none; font-style: italic;
    }
    .bubble-style-whisper .bubble-tail {
        position: absolute; bottom: -16px; left: 36px;
        width: 0; height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-top: 16px solid #000;
    }
    .bubble-style-whisper .bubble-tail::after {
        content: ''; position: absolute; top: -15px; left: -5px;
        width: 0; height: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 12px solid #fff;
    }

    /* ‚îÄ‚îÄ Style 8: Electric / Scream ‚îÄ‚îÄ */
    .bubble-style-electric {
        border: 3.5px solid #000;
        background: #fff;
        clip-path: polygon(
            8% 0%, 92% 0%, 100% 8%, 100% 92%, 92% 100%,
            65% 100%, 60% 115%, 52% 100%,
            8% 100%, 0% 92%, 0% 8%
        );
        padding: 14px 18px 24px;
        box-shadow: none;
    }
    .bubble-style-electric .bubble-tail { display: none; }

    /* ‚îÄ‚îÄ Style 9: Square with Side Tail (narrator box) ‚îÄ‚îÄ */
    .bubble-style-narrator {
        border: 3px solid #000; border-radius: 6px;
        background: #fffde7;
        box-shadow: 5px 5px 0 #000;
        border-left: 6px solid #000;
    }
    .bubble-style-narrator .bubble-tail { display: none; }

    /* ‚îÄ‚îÄ Legacy/fallback (old thinking style) ‚îÄ‚îÄ */
    .thinking .bubble-tail { display: none; }

    .toolbar-bottom { 
        height: 85px; background: var(--card); border-top: 1px solid var(--border); 
        display: flex; justify-content: space-around; align-items: center; z-index: 2000;
    }
    .tool-btn { 
        background: none; border: none; color: #8e8e93; cursor: pointer; 
        display: flex; flex-direction: column; align-items: center; gap: 4px;
        font-size: 10px; font-weight: 700; transition: 0.2s;
    }
    .tool-btn:hover { color: white; }
    .tool-btn.active-tool { color: var(--accent); }
    .tool-icon { font-size: 22px; }

    .menu-popup { 
        position: fixed; bottom: 100px; background: var(--card); 
        border: 1px solid var(--border); border-radius: 18px; display: none; 
        flex-direction: column; width: 240px; padding: 12px; gap: 8px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5); z-index: 2100; 
    }
    .menu-item { 
        background: #2c2c2e; color: white; border: none; padding: 12px; 
        border-radius: 10px; text-align: left; font-size: 13px; cursor: pointer; 
        display: flex; align-items: center; gap: 10px; font-weight: 600;
    }
    .menu-item:hover { background: #3a3a3c; }

    #transform-ui { 
        position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); 
        background: var(--card); padding: 20px; border-radius: 24px; 
        border: 1px solid var(--accent); display: none; flex-direction: column;
        gap: 15px; z-index: 3500; width: 300px; min-width: 240px; min-height: 100px;
        box-shadow: 0 15px 40px rgba(0,0,0,0.6);
        resize: both; overflow: auto;
    }
    #transform-ui-header {
        cursor: grab; user-select: none; display: flex; justify-content: space-between; align-items: center;
    }
    #transform-ui-header:active { cursor: grabbing; }
    #transform-ui.minimized .transform-ui-collapsible { display: none !important; }
    #transform-ui.minimized { gap: 8px; }
    .slider-group { display: flex; flex-direction: column; gap: 4px; width: 100%; }
    .slider-group-row { display: flex; align-items: center; gap: 10px; width: 100%; }
    .slider-group span { font-size: 10px; width: 56px; font-weight: 800; color: #8e8e93; text-transform: uppercase; flex-shrink: 0; }
    .slider-group input[type="range"] { flex: 1; accent-color: var(--accent); }
    .slider-num-input {
        width: 52px; background: #111; border: 1px solid #333; color: var(--accent);
        padding: 4px 6px; border-radius: 7px; font-size: 11px; font-weight: 800;
        text-align: center; font-family: inherit; outline: none; flex-shrink: 0;
    }
    .slider-num-input:focus { border-color: var(--accent); }
    .slider-num-input::-webkit-inner-spin-button,
    .slider-num-input::-webkit-outer-spin-button { opacity: 1; }

    .text-settings-row {
        display: none; border-top: 1px solid #333; padding-top: 15px; flex-direction: column; gap: 10px;
    }
    .text-input-field {
        background: #111; border: 1px solid #333; color: white; padding: 8px; border-radius: 8px; font-family: inherit;
    }

    .overlay-full { 
        position: absolute; inset: 0; background: rgba(0,0,0,0.9); 
        z-index: 3000; display: none; flex-direction: column; 
        align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(5px);
    }
    body { position: relative; }
    .modal-content { 
        background: var(--card); width: 100%; max-width: 500px; 
        border-radius: 24px; padding: 30px; box-sizing: border-box; 
        max-height: 90vh; overflow-y: auto; border: 1px solid var(--border);
    }

    .action-selector-grid { 
        display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 15px; 
    }
    .action-option { 
        background: #111; border: 2px solid #333; padding: 8px; 
        border-radius: 12px; cursor: pointer; text-align: center; transition: 0.2s;
    }
    .action-option:hover { border-color: var(--teal); transform: translateY(-2px); }
    .action-option img { width: 100%; aspect-ratio: 1; object-fit: contain; }
    .action-option span { font-size: 10px; color: #888; display: block; margin-top: 5px; }

    #global-frame-indicator {
        position: absolute; bottom: -30px; left: 50%; transform: translateX(-50%);
        font-weight: 900; font-size: 12px; color: #444; letter-spacing: 2px;
    }

    .pub-input { width: 100%; padding: 14px; background: #111; border: 1px solid #333; color: white; border-radius: 12px; margin-bottom: 12px; box-sizing: border-box; font-family: inherit; }

    /* ‚îÄ‚îÄ Export Modal ‚îÄ‚îÄ */
    #export-modal .modal-content { max-width: 380px; }
    .export-tab-row { display: flex; gap: 0; border-radius: 10px; overflow: hidden; border: 1px solid var(--border); margin-bottom: 20px; }
    .export-tab { flex: 1; padding: 10px; text-align: center; font-weight: 800; font-size: 13px; cursor: pointer; background: #1a1a1a; color: #666; transition: 0.2s; border: none; }
    .export-tab.active { background: var(--teal); color: #000; }
    .export-section { display: none; flex-direction: column; gap: 12px; }
    .export-section.active { display: flex; }
    .export-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; font-weight: 600; }
    .export-row input[type=range] { width: 130px; }
    .export-row span.val { min-width: 40px; text-align: right; font-weight: 800; color: var(--teal); }
    .export-progress { width: 100%; height: 6px; background: #222; border-radius: 10px; overflow: hidden; margin-top: 4px; display: none; }
    .export-progress-fill { height: 100%; background: var(--teal); width: 0%; transition: width 0.3s; }
    .export-status { font-size: 11px; color: var(--secondary); text-align: center; min-height: 16px; }

    /* ‚îÄ‚îÄ iOS Markup-style Float Toolbar ‚îÄ‚îÄ */
    #ftb-pill {
        position: fixed; z-index: 8000; display: none;
        align-items: center;
        pointer-events: none;
        transform: translateX(-50%);
        transition: top 0.15s ease, left 0.15s ease;
        position: fixed;
    }
    #ftb-pill.visible { display: flex; }

    /* Expanded panel (appears above pill) */
    #ftb-panel {
        background: #1c1c1e; border-radius: 16px;
        padding: 12px 14px; display: none; flex-direction: column; gap: 10px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.7);
        min-width: 240px; pointer-events: all;
        border: 1px solid rgba(255,255,255,0.08);
        position: absolute;
        bottom: calc(100% + 12px);
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
    }
    #ftb-panel.open { display: flex; }

    /* Panel rows */
    .ftb-panel-row {
        display: flex; align-items: center; gap: 6px;
    }
    .ftb-p-btn {
        background: #2c2c2e; border: none; color: #fff;
        border-radius: 10px; padding: 8px 12px; cursor: pointer;
        font-size: 15px; font-weight: 700; flex: 1; text-align: center;
        transition: 0.15s; font-family: inherit; line-height: 1;
    }
    .ftb-p-btn:hover  { background: #3a3a3c; }
    .ftb-p-btn.active { background: var(--accent); color: #000; }
    .ftb-p-btn.danger { color: #ff453a; }

    /* Color wheel button */
    #ftb-color-btn {
        width: 34px; height: 34px; border-radius: 50%; border: 3px solid #555;
        cursor: pointer; background: #000; flex-shrink: 0;
        box-shadow: 0 0 0 1px #333;
    }

    /* Size row */
    .ftb-size-row {
        display: flex; align-items: center; background: #2c2c2e;
        border-radius: 12px; overflow: hidden;
    }
    .ftb-size-btn {
        background: none; border: none; color: #fff;
        padding: 8px 18px; font-size: 20px; cursor: pointer;
        font-weight: 300; line-height: 1; flex-shrink: 0;
    }
    .ftb-size-btn:hover { background: #3a3a3c; }
    .ftb-size-num {
        flex: 1; text-align: center; font-size: 15px;
        font-weight: 700; color: #fff; pointer-events: none;
    }

    /* Font picker */
    .ftb-font-select {
        flex: 1; background: #2c2c2e; border: none; color: #fff;
        border-radius: 10px; padding: 8px 10px; font-size: 13px;
        outline: none; cursor: pointer;
    }

    /* Align row */
    .ftb-align-btn {
        background: #2c2c2e; border: none; color: #fff;
        border-radius: 10px; padding: 8px; cursor: pointer;
        font-size: 16px; flex: 1; text-align: center; transition: 0.15s;
    }
    .ftb-align-btn:hover  { background: #3a3a3c; }
    .ftb-align-btn.active { background: var(--accent); color: #000; }

    /* Panel caret triangle */
    #ftb-caret {
        width: 0; height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-top: 8px solid #1c1c1e;
        pointer-events: none;
        position: absolute;
        bottom: calc(100% + 4px);
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
    }

    /* Main pill */
    #ftb-bar {
        background: #fff; border-radius: 50px;
        display: flex; align-items: center; gap: 0;
        box-shadow: 0 4px 20px rgba(0,0,0,0.35);
        overflow: visible; pointer-events: all;
        height: 44px;
        position: relative;
    }
    .ftb-pill-btn {
        background: none; border: none; cursor: pointer;
        padding: 0 14px; height: 44px; display: flex;
        align-items: center; justify-content: center;
        font-size: 14px; color: #111; font-weight: 600;
        font-family: inherit; transition: background 0.1s;
        gap: 5px; white-space: nowrap;
    }
    .ftb-pill-btn:hover { background: #f0f0f0; }
    .ftb-pill-sep {
        width: 1px; height: 24px; background: #ddd; flex-shrink: 0;
    }

    /* Hidden color input */
    #ftb-color-input { display: none; }

    /* ‚îÄ‚îÄ Background Edit Panel ‚îÄ‚îÄ */
    #bg-edit-panel {
        position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
        background: var(--card); border: 1px solid var(--border); border-radius: 20px;
        padding: 16px; width: 340px; display: none; flex-direction: column; gap: 12px;
        z-index: 2200; box-shadow: 0 12px 40px rgba(0,0,0,0.6);
    }
    #bg-edit-panel .panel-title {
        font-size: 11px; font-weight: 900; color: var(--accent); letter-spacing: 1px;
        text-transform: uppercase; display: flex; justify-content: space-between; align-items: center;
    }
    .bg-slider-row { display: flex; align-items: center; gap: 10px; }
    .bg-slider-row span { font-size: 10px; color: #888; font-weight: 800; width: 60px; text-transform: uppercase; }
    .bg-slider-row input[type=range] { flex: 1; accent-color: var(--accent); }
    .bg-slider-row .val-label { font-size: 10px; font-weight: 800; color: var(--teal); min-width: 32px; text-align: right; }

    /* Filter chip scroll row */
    .filter-row {
        display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px;
    }
    .filter-row::-webkit-scrollbar { height: 3px; }
    .filter-row::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    .filter-chip {
        flex-shrink: 0; padding: 6px 12px; border-radius: 20px;
        background: #2c2c2e; border: 1.5px solid #3a3a3c;
        color: #aaa; font-size: 11px; font-weight: 700; cursor: pointer; transition: 0.15s;
        white-space: nowrap;
    }
    .filter-chip.active { background: var(--accent); color: #000; border-color: var(--accent); }

    /* ‚îÄ‚îÄ Sprite Blur Panel (inside transform-ui) ‚îÄ‚îÄ */
    #sprite-blur-row {
        display: none; flex-direction: column; gap: 8px;
        border-top: 1px solid #333; padding-top: 10px; margin-top: 2px;
    }
    .blur-type-row { display: flex; gap: 6px; }
    .blur-type-btn {
        flex: 1; padding: 7px; background: #2c2c2e; border: 1.5px solid #3a3a3c;
        color: #aaa; font-size: 11px; font-weight: 800; border-radius: 8px; cursor: pointer; transition: 0.15s;
    }
    .blur-type-btn.active { background: var(--teal); color: #000; border-color: var(--teal); }

    /* ‚îÄ‚îÄ Sprite Name Tag (editor-only overlay) ‚îÄ‚îÄ */
    .sprite-nametag {
        position: absolute; bottom: -22px; left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.75); color: var(--accent);
        font-size: 10px; font-weight: 900; padding: 2px 8px; border-radius: 4px;
        white-space: nowrap; pointer-events: none; letter-spacing: 0.5px;
        border: 1px solid rgba(255,122,0,0.3);
    }

    /* ‚îÄ‚îÄ Multi-frame Import Modal ‚îÄ‚îÄ */
    #multi-import-modal .modal-content { max-width: 460px; }
    .multi-drop-zone {
        border: 2px dashed #444; border-radius: 14px; padding: 30px 20px;
        text-align: center; cursor: pointer; transition: 0.2s; background: #111;
    }
    .multi-drop-zone:hover, .multi-drop-zone.dragover { border-color: var(--accent); background: #1a1a1a; }
    .multi-drop-zone p { margin: 8px 0 0; color: #666; font-size: 12px; }
    #multi-preview-grid {
        display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
        gap: 8px; max-height: 220px; overflow-y: auto; margin-top: 12px;
    }
    .multi-thumb {
        aspect-ratio: 1; border-radius: 8px; background-size: cover; background-position: center;
        border: 2px solid #333; position: relative; overflow: hidden;
    }
    .multi-thumb .order-badge {
        position: absolute; top: 3px; left: 3px; background: var(--accent); color: #000;
        font-size: 9px; font-weight: 900; padding: 1px 5px; border-radius: 3px;
    }
    .multi-ratio-warning {
        font-size: 11px; color: var(--danger); text-align: center;
        display: none; margin-top: 6px;
    }

    /* ‚îÄ‚îÄ FX Panel (layer blur + filter) ‚îÄ‚îÄ */
    #fx-panel {
        position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%);
        background: var(--card); border: 1px solid var(--border); border-radius: 20px;
        padding: 16px; width: min(380px, 96vw); display: none; flex-direction: column; gap: 12px;
        z-index: 2300; box-shadow: 0 12px 40px rgba(0,0,0,0.7);
    }
    #fx-panel .fx-title {
        font-size: 11px; font-weight: 900; color: var(--teal); letter-spacing: 1px;
        text-transform: uppercase; display: flex; justify-content: space-between; align-items: center;
    }
    .fx-section-label { font-size: 10px; font-weight: 900; color: #555; text-transform: uppercase; letter-spacing: 1px; margin-top: 4px; }
    .fx-filter-row { display: flex; gap: 6px; overflow-x: auto; padding-bottom: 3px; }
    .fx-filter-row::-webkit-scrollbar { height: 3px; }
    .fx-filter-row::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    .fx-chip {
        flex-shrink: 0; padding: 5px 11px; border-radius: 16px;
        background: #2c2c2e; border: 1.5px solid #3a3a3c;
        color: #aaa; font-size: 10px; font-weight: 700; cursor: pointer; transition: 0.15s;
    }
    .fx-chip.active { background: var(--teal); color: #000; border-color: var(--teal); }
    /* Multi-select in layer panel */
    .layer-item-sel { background: rgba(0,210,255,0.15); border-color: var(--teal) !important; }
    #fx-selected-hint { font-size: 10px; color: #555; font-weight: 700; }
    .sb-layer-item.locked-l { opacity: 0.45; border-color: #2a2a2a !important; }
    .sb-layer-item .lock-btn {
        margin-left: auto; background: none; border: none; cursor: pointer;
        font-size: 13px; padding: 2px 4px; border-radius: 4px; color: #444; transition: 0.12s; flex-shrink: 0;
    }
    .sb-layer-item .lock-btn:hover { color: #aaa; }
    .sb-layer-item.locked-l .lock-btn { color: #ff9500; }

    /* Selection outline opacity control */
    .layer.active { outline: 2px solid var(--accent); outline-offset: 1px; }

    /* BG Edit Panel number inputs */
    .bg-num-input {
        width: 44px; background: #111; border: 1px solid #333; color: var(--text);
        padding: 3px 5px; border-radius: 6px; font-size: 11px; font-weight: 700;
        text-align: center; outline: none; font-family: inherit;
    }
    .bg-num-input:focus { border-color: var(--accent); }
    .bg-slider-row { display: flex; align-items: center; gap: 7px; }
    .bg-slider-row span:first-child { font-size: 10px; font-weight: 800; color: #666; text-transform: uppercase; letter-spacing: 0.5px; width: 38px; flex-shrink: 0; }
    .bg-slider-row input[type=range] { flex: 1; }

    /* Hide UI overlay arrow button */
    #ui-reveal-btn {
        position: fixed; left: 0; top: 50%; transform: translateY(-50%);
        width: 22px; height: 56px; background: var(--accent); color: #000;
        border: none; border-radius: 0 10px 10px 0; cursor: pointer;
        font-size: 13px; font-weight: 900; z-index: 9999;
        display: none; align-items: center; justify-content: center;
        box-shadow: 3px 0 12px rgba(0,0,0,0.5); transition: 0.15s;
    }
    #ui-reveal-btn:hover { width: 28px; }

    /* Selection opacity: applied via CSS variable */
    .layer.active { outline-color: rgba(var(--sel-r,255), var(--sel-g,122), var(--sel-b,0), var(--sel-opacity, 1)); }

    /* Bg recrop button */
    #bg-recrop-btn {
        display: flex; align-items: center; gap: 8px; width: 100%;
        padding: 9px 12px; background: #0a1020; border: 1px solid #00d2ff44;
        color: var(--teal); border-radius: 8px; font-weight: 800; font-size: 11px;
        cursor: pointer; font-family: inherit; transition: 0.15s;
    }
    #bg-recrop-btn:hover { background: #0a1a2a; border-color: var(--teal); }

    /* Editor prefs panel */
    #editor-prefs-panel {
        position: fixed; right: 16px; bottom: 100px; z-index: 3000;
        background: var(--card); border: 1px solid var(--border); border-radius: 16px;
        padding: 16px; width: 260px; display: none; flex-direction: column; gap: 12px;
        box-shadow: 0 12px 40px rgba(0,0,0,0.7);
    }
    #editor-prefs-panel .prefs-title {
        font-size: 10px; font-weight: 900; color: var(--accent); letter-spacing: 1.5px;
        text-transform: uppercase; display: flex; justify-content: space-between;
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       CANVA-STYLE APP SHELL
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    
    /* Override old layout styles */
    .toolbar-top, .toolbar-bottom, #frame-drawer { display: none !important; }
    .menu-popup { display: none !important; }

    body {
        overflow: hidden; display: flex; flex-direction: column; height: 100vh;
        margin: 0; font-family: 'Inter', sans-serif;
        background: var(--bg); color: var(--text);
    }

    #cc-app { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

    /* ‚îÄ‚îÄ TOP BAR ‚îÄ‚îÄ */
    #top-bar {
        height: 54px; background: var(--card); border-bottom: 1px solid var(--border);
        display: flex; align-items: center; gap: 6px;
        padding: 0 10px; z-index: 2000; flex-shrink: 0;
        box-shadow: 0 2px 10px rgba(0,0,0,0.4);
    }
    .tb-brand {
        font-size: 13px; font-weight: 900; color: var(--accent);
        letter-spacing: 1.5px; padding: 0 8px; white-space: nowrap;
    }
    .tb-sep { width: 1px; height: 26px; background: var(--border); flex-shrink: 0; margin: 0 2px; }
    .tb-spacer { flex: 1; }
    .tb-btn {
        background: rgba(255,255,255,0.06); border: 1px solid var(--border); color: var(--text);
        padding: 6px 11px; border-radius: 8px; cursor: pointer; font-size: 11px; font-weight: 700;
        transition: 0.15s; display: flex; align-items: center; gap: 5px; white-space: nowrap;
        font-family: inherit;
    }
    .tb-btn:hover { background: rgba(255,255,255,0.1); border-color: #555; }
    .tb-btn.accent { background: var(--accent); color: #000; border-color: var(--accent); font-size: 12px; font-weight: 900; }
    .tb-btn.accent:hover { opacity: 0.88; }
    .tb-btn.teal-btn { border-color: var(--teal); color: var(--teal); background: rgba(0,210,255,0.07); }
    .tb-btn.icon-btn { padding: 6px 9px; font-size: 15px; }
    #onion-skin-control {
        gap: 8px; align-items: center; background: rgba(255,255,255,0.04);
        padding: 4px 10px; border-radius: 8px; border: 1px solid var(--border); flex-shrink: 0;
    }
    #onion-skin-control label { font-size: 9px; font-weight: 900; color: var(--text); letter-spacing: 0.5px; }

    /* ‚îÄ‚îÄ WORK AREA ‚îÄ‚îÄ */
    #work-area { flex: 1; display: flex; overflow: hidden; }

    /* ‚îÄ‚îÄ LEFT SIDEBAR ‚îÄ‚îÄ */
    #left-sidebar {
        display: flex; flex-direction: row; flex-shrink: 0;
        z-index: 1500;
    }
    #sidebar-icons {
        width: 64px; display: flex; flex-direction: column; align-items: center;
        padding: 8px 0; gap: 1px; background: #0d0d0d; border-right: 1px solid #1a1a1a;
        flex-shrink: 0; overflow-y: auto;
    }
    .sb-icon-btn {
        width: 54px; height: 54px; border: none; background: none; color: #555;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        gap: 3px; cursor: pointer; border-radius: 10px; transition: 0.15s;
        font-size: 8.5px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.5px;
        font-family: inherit;
    }
    .sb-icon-btn:hover { background: rgba(255,255,255,0.05); color: #aaa; }
    .sb-icon-btn.active { background: rgba(255,122,0,0.15); color: var(--accent); }
    .sb-icon-btn.teal-icon.active { background: rgba(0,210,255,0.12); color: var(--teal); }
    .sb-icon-btn.teal-icon.active { background: rgba(0,210,255,0.12); color: var(--teal); }
    .sb-icon-btn.danger-icon.active { background: rgba(255,59,48,0.12); color: var(--danger); }
    .sb-icon { font-size: 21px; line-height: 1; }
    .sb-custom-icon { width: 22px; height: 22px; object-fit: contain; display: block; }
    .sb-divider { width: 36px; height: 1px; background: #1a1a1a; margin: 4px 0; flex-shrink: 0; }

    /* ‚îÄ‚îÄ SIDEBAR PANEL ‚îÄ‚îÄ */
    #sidebar-panel {
        width: 0; overflow: hidden;
        transition: width 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        background: #111; border-right: 1px solid #1a1a1a;
        display: flex; flex-direction: column;
    }
    #sidebar-panel.open { width: 280px; }

    .sp-content {
        width: 280px; height: 100%; display: none; flex-direction: column; overflow: hidden;
    }
    .sp-content.active { display: flex; }
    .sp-header {
        padding: 12px 14px 10px; font-size: 10px; font-weight: 900; color: var(--accent);
        letter-spacing: 2px; text-transform: uppercase; border-bottom: 1px solid #1a1a1a;
        display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;
    }
    .sp-close-btn { cursor: pointer; color: #444; font-size: 15px; font-weight: 900; transition: 0.12s; }
    .sp-close-btn:hover { color: #aaa; }

    /* Sprites panel */
    .sp-search {
        margin: 10px 10px 6px; padding: 8px 12px; background: #1a1a1a; border: 1px solid #252525;
        color: white; border-radius: 8px; font-size: 12px; font-weight: 600; outline: none;
        font-family: inherit; flex-shrink: 0;
    }
    .sp-search:focus { border-color: var(--accent); }
    #sb-sprite-grid {
        flex: 1; overflow-y: auto; padding: 6px 8px 10px;
        display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
        align-content: start;
    }
    #sb-sprite-grid::-webkit-scrollbar { width: 3px; }
    #sb-sprite-grid::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    .sb-sprite-card {
        background: var(--card); border: 2px solid var(--border); border-radius: 12px;
        cursor: pointer; overflow: hidden; transition: 0.2s;
        display: flex; flex-direction: column; position: relative;
        height: 100px;
    }
    .sb-sprite-card:hover { border-color: var(--accent); transform: translateY(-3px); box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
    .sb-sprite-card img { width: 100%; flex: 1; object-fit: contain; padding: 8px; box-sizing: border-box; min-height: 0; opacity: 0; transition: opacity 0.2s; }
    .sb-sprite-card img.sb-loaded { opacity: 1; }
    .sb-skeleton {
        flex: 1; border-radius: 6px; margin: 8px 8px 4px;
        background: linear-gradient(90deg, #1e1e1e 25%, #2a2a2a 50%, #1e1e1e 75%);
        background-size: 200% 100%;
        animation: sb-shimmer 1.4s infinite;
    }
    @keyframes sb-shimmer {
        0%   { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
    .sb-sprite-card span {
        font-size: 9px; font-weight: 800; color: #888; padding: 3px 6px 5px;
        text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        background: rgba(0,0,0,0.4); flex-shrink: 0;
    }
    .sp-load-msg { text-align: center; padding: 30px 16px; color: #333; font-size: 12px; font-weight: 700; grid-column: 1/-1; }

    /* Add panel */
    .sp-section-label {
        font-size: 9px; font-weight: 900; color: #2a2a2a; text-transform: uppercase;
        letter-spacing: 1.5px; padding: 10px 14px 4px; flex-shrink: 0;
    }
    .sp-action-btn {
        display: flex; align-items: center; gap: 10px;
        padding: 10px 14px; cursor: pointer; border: none; background: none; color: #888;
        font-size: 13px; font-weight: 600; font-family: inherit; width: 100%;
        text-align: left; transition: 0.12s;
    }
    .sp-action-btn:hover { background: rgba(255,255,255,0.04); color: white; }
    .sp-action-icon { font-size: 18px; width: 28px; text-align: center; flex-shrink: 0; }
    .sp-add-scroll { flex: 1; overflow-y: auto; }

    /* Layers panel */
    #sb-layer-actions {
        display: flex; gap: 5px; padding: 8px 10px; border-bottom: 1px solid #1a1a1a; flex-shrink: 0;
    }
    .sb-lay-btn {
        flex: 1; padding: 6px 2px; background: #1a1a1a; border: 1px solid #252525; color: #777;
        border-radius: 7px; font-size: 9.5px; font-weight: 800; cursor: pointer; text-align: center;
        transition: 0.12s; font-family: inherit; white-space: nowrap;
    }
    .sb-lay-btn:hover { background: #222; color: white; }
    .sb-lay-btn.danger { color: #ff453a; }
    #sb-layer-list {
        flex: 1; overflow-y: auto; padding: 6px;
        display: flex; flex-direction: column; gap: 4px;
    }
    #sb-layer-list::-webkit-scrollbar { width: 3px; }
    #sb-layer-list::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    .sb-layer-item {
        display: flex; align-items: center; gap: 8px; padding: 8px 10px; cursor: pointer;
        border-radius: 8px; border: 1.5px solid transparent; background: #191919; transition: 0.12s;
        font-size: 11px; font-weight: 700; color: #666;
    }
    .sb-layer-item:hover { border-color: #2a2a2a; color: #aaa; }
    .sb-layer-item.active-l { border-color: var(--accent); color: var(--accent); background: rgba(255,122,0,0.07); }
    .sb-layer-item.multi-l { border-color: var(--teal); background: rgba(0,210,255,0.07); color: var(--teal); }
    .sb-layer-icon { font-size: 14px; flex-shrink: 0; }

    /* ‚îÄ‚îÄ VIEWPORT ‚îÄ‚îÄ */
    #viewport {
        flex: 1; display: flex; justify-content: center; align-items: center;
        background: #050505; position: relative; overflow: hidden;
    }
    #canvas-container { position: relative; display: inline-block; }
    #global-frame-indicator {
        position: absolute; bottom: -26px; left: 50%; transform: translateX(-50%);
        font-weight: 900; font-size: 11px; color: #2a2a2a; letter-spacing: 2px;
        white-space: nowrap;
    }

    /* ‚îÄ‚îÄ FRAME STRIP ‚îÄ‚îÄ */
    #frame-strip {
        height: 88px; background: #0a0a0a; border-top: 1px solid #1a1a1a;
        display: flex; align-items: center; flex-shrink: 0; overflow: hidden; z-index: 1600;
    }
    #fs-nav {
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        gap: 5px; padding: 0 10px; border-right: 1px solid #1a1a1a; height: 100%; flex-shrink: 0; min-width: 84px;
    }
    .fs-nav-row { display: flex; gap: 3px; }
    #frame-label { font-size: 10px; font-weight: 900; color: var(--accent); letter-spacing: 1px; }
    .fs-nav-btn {
        background: #1a1a1a; border: 1px solid #2a2a2a; color: #666; width: 26px; height: 26px;
        border-radius: 5px; cursor: pointer; font-size: 11px; display: flex; align-items: center;
        justify-content: center; transition: 0.12s; font-family: inherit;
    }
    .fs-nav-btn:hover { background: #222; color: white; }
    #thumb-container {
        flex: 1; display: flex; gap: 8px; overflow-x: auto; align-items: center;
        padding: 0 12px; height: 100%;
    }
    #thumb-container::-webkit-scrollbar { height: 3px; }
    #thumb-container::-webkit-scrollbar-thumb { background: #2a2a2a; border-radius: 3px; }
    .frame-thumb {
        min-width: 78px; height: 62px; background: #1a1a1a; border: 2px solid #2a2a2a;
        border-radius: 7px; cursor: pointer; display: flex; align-items: center;
        justify-content: center; font-size: 10px; flex-shrink: 0; font-weight: 900;
        background-size: cover; background-position: center; transition: 0.15s;
        color: #333; position: relative;
    }
    .frame-thumb:hover { border-color: #444; }
    .frame-thumb.active { border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent); }
    #fs-actions {
        display: flex; flex-direction: column; gap: 4px;
        padding: 0 10px; border-left: 1px solid #1a1a1a; height: 100%;
        justify-content: center; flex-shrink: 0;
    }
    .fs-act-row { display: flex; gap: 4px; }
    .fs-act-btn {
        padding: 5px 8px; background: #1a1a1a; border: 1px solid #2a2a2a; color: #666;
        border-radius: 6px; font-size: 9.5px; font-weight: 800; cursor: pointer; transition: 0.12s;
        white-space: nowrap; font-family: inherit;
    }
    .fs-act-btn:hover { background: #222; color: white; }
    .fs-act-btn.add-frame { background: rgba(255,122,0,0.12); border-color: rgba(255,122,0,0.4); color: var(--accent); }
    .fs-act-btn.danger { color: #ff453a; }

    /* ‚îÄ‚îÄ Override old panel bottom positions for new layout ‚îÄ‚îÄ */
    #transform-ui { z-index: 3500; bottom: 100px; }
    #bg-edit-panel { z-index: 3500; bottom: 100px; }
    #fx-panel { z-index: 3500; bottom: 100px; }

    /* Prevent scrollbar flicker */
    #work-area::-webkit-scrollbar { display: none; }

</style></head>
<body>

<!-- ‚îÄ‚îÄ OVERLAY MODALS (unchanged) ‚îÄ‚îÄ -->
<div id="library-modal" class="overlay-full">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2 style="margin:0; color:var(--teal); letter-spacing: 1px;">SPRITE LIBRARY</h2>
            <span onclick="closeLibrary()" style="cursor:pointer; font-size: 24px;">‚úï</span>
        </div>
        <div id="library-grid" class="action-selector-grid" style="grid-template-columns: repeat(2, 1fr); margin-top:20px;"></div>
    </div>
</div>

<div id="action-modal" class="overlay-full">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2 style="margin:0; color:var(--teal);" id="pack-title">Character Pack</h2>
            <span onclick="closeActionModal()" style="cursor:pointer; font-size: 24px;">‚úï</span>
        </div>
        <div id="action-selector-list" class="action-selector-grid"></div>
    </div>
</div>

<div id="publish-modal" class="overlay-full">
    <div class="modal-content">
        <h2 style="margin-top:0; color:var(--accent);">Publish Comic</h2>
        <div id="cover-preview-box" style="width:100%; aspect-ratio: 1; background:#111; border:2px dashed #444; margin-bottom:15px; display:flex; align-items:center; justify-content:center; cursor:pointer; overflow:hidden; border-radius: 12px;" onclick="document.getElementById('cover-input').click()">
            <img id="final-cover-img" style="width:100%; height:100%; object-fit:cover; display:none;">
            <span id="cover-label">Click to upload 1:1 Cover</span>
        </div>
        <input type="text" id="pub-title" class="pub-input" placeholder="Comic Title">
        <input type="text" id="pub-tags" class="pub-input" placeholder="Tags (e.g. action, comedy, scifi)">
        <textarea id="pub-desc" class="pub-input" placeholder="Brief description..." style="height: 80px;"></textarea>
        <div style="display:flex; gap:12px;">
            <button onclick="closePublish()" style="flex:1; padding:14px; background:#333; color:white; border:none; border-radius:12px; font-weight:700;">Cancel</button>
            <button id="publish-btn" onclick="finalPublish()" style="flex:1; padding:14px; background:var(--accent); color:white; border:none; border-radius:12px; font-weight:900;">POST NOW</button>
        </div>
    </div>
</div>

<div id="crop-modal" class="overlay-full">
    <div style="width: 80vw; height: 60vh; background: #000; border-radius: 12px; overflow: hidden;"><img id="crop-target" style="max-width: 100%;"></div>
    <div style="margin-top:20px; display:flex; gap:15px;">
        <button class="nav-btn" onclick="closeCrop()">Cancel</button>
        <button class="nav-btn" style="background:var(--accent); border: none; padding: 10px 30px;" id="apply-crop-btn">Apply</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ Background Import Choice Modal ‚îÄ‚îÄ -->
<div id="bg-import-choice-modal" class="overlay-full" style="display:none;">
    <div style="background:var(--card); border-radius:24px; padding:28px; width:90%; max-width:400px; border:1px solid var(--border); display:flex; flex-direction:column; gap:18px; box-shadow:0 20px 60px rgba(0,0,0,0.7);">
        <div style="text-align:center;">
            <div style="font-size:13px; font-weight:900; color:var(--accent); letter-spacing:2px; text-transform:uppercase; margin-bottom:6px;">Import Background</div>
            <div style="font-size:11px; color:#555; font-weight:600;">How would you like to import this image?</div>
        </div>
        <div style="width:100%; height:140px; background:#000; border-radius:12px; overflow:hidden;">
            <img id="bg-choice-preview" style="width:100%; height:100%; object-fit:cover;">
        </div>
        <div style="display:flex; flex-direction:column; gap:10px;">
            <button onclick="bgChoiceCrop()" style="
                display:flex; align-items:center; gap:14px; padding:16px 18px;
                background:#1a1a1a; border:2px solid #2c2c2e; border-radius:14px;
                cursor:pointer; text-align:left; transition:0.2s; width:100%; font-family:inherit;
                color:white;" onmouseover="this.style.borderColor='var(--accent)'" onmouseout="this.style.borderColor='#2c2c2e'">
                <span style="font-size:26px;">‚úÇÔ∏è</span>
                <div>
                    <div style="font-size:13px; font-weight:900; color:white;">Crop Import</div>
                    <div style="font-size:11px; color:#666; margin-top:2px;">Manually adjust the crop to fit your canvas ratio.</div>
                </div>
            </button>
            <button onclick="bgChoiceFixed()" style="
                display:flex; align-items:center; gap:14px; padding:16px 18px;
                background:#1a1a1a; border:2px solid #2c2c2e; border-radius:14px;
                cursor:pointer; text-align:left; transition:0.2s; width:100%; font-family:inherit;
                color:white;" onmouseover="this.style.borderColor='var(--teal)'" onmouseout="this.style.borderColor='#2c2c2e'">
                <span style="font-size:26px;">‚ö°</span>
                <div>
                    <div style="font-size:13px; font-weight:900; color:var(--teal);">Fixed Import</div>
                    <div style="font-size:11px; color:#666; margin-top:2px;">Auto-center crop to canvas ratio. No extra steps.</div>
                </div>
            </button>
        </div>
        <button onclick="closeBgChoiceModal()" style="padding:11px; background:#111; color:#555; border:none; border-radius:12px; font-weight:700; cursor:pointer; font-size:12px; font-family:inherit;">Cancel</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ FX Panel (layer-level blur + filters, multi-select) ‚îÄ‚îÄ -->

<!-- ‚îÄ‚îÄ FLOATING PANELS (unchanged) ‚îÄ‚îÄ -->
<div id="fx-panel">
    <div class="fx-title">
        <span>üé® FX ‚Äî LAYER EFFECTS</span>
        <span style="cursor:pointer;color:#555;" onclick="closeFxPanel()">‚úï</span>
    </div>
    <div id="fx-selected-hint">Select layer(s) in LAYERS panel first</div>

    <!-- Blur -->
    <div class="fx-section-label">Blur</div>
    <div style="display:flex; gap:6px;">
        <button class="fx-chip active" id="fx-blur-none" onclick="setFxBlur('none')">None</button>
        <button class="fx-chip" id="fx-blur-soft" onclick="setFxBlur('soft')">Soft</button>
        <button class="fx-chip" id="fx-blur-pixel" onclick="setFxBlur('pixel')">Pixelate</button>
    </div>
    <div id="fx-blur-amt-row" style="display:none;" class="bg-slider-row">
        <span>Amount</span>
        <input type="range" id="fx-blur-amt" min="1" max="20" value="4" oninput="applyFxToSelected()">
        <span class="val-label" id="fx-blur-amt-val">4px</span>
    </div>

    <!-- Filter -->
    <div class="fx-section-label">Filter</div>
    <div class="fx-filter-row" id="fx-filter-row"></div>

    <!-- Opacity -->
    <div class="fx-section-label">Opacity</div>
    <div class="bg-slider-row">
        <span>Opacity</span>
        <input type="range" id="fx-opacity" min="10" max="100" value="100" oninput="applyFxToSelected()">
        <span class="val-label" id="fx-opacity-val">100%</span>
    </div>

    <div style="display:flex;gap:8px;">
        <button onclick="clearFxFromSelected()" style="flex:1;padding:8px;background:#222;color:#aaa;border:none;border-radius:8px;font-weight:700;font-size:11px;cursor:pointer;">Clear FX</button>
        <button onclick="closeFxPanel()" style="flex:1;padding:8px;background:var(--teal);color:#000;border:none;border-radius:8px;font-weight:800;font-size:11px;cursor:pointer;">Done</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ Background Edit Panel ‚îÄ‚îÄ -->
<div id="bg-edit-panel">
    <div class="panel-title">
        <span>üñºÔ∏è BACKGROUND EDIT</span>
        <span style="cursor:pointer; color:#555;" onclick="closeBgPanel()">‚úï</span>
    </div>
    <button id="bg-recrop-btn" onclick="openBgRecrop()">‚úÇÔ∏è Re-crop / Edit Crop</button>
    <button id="bg-move-btn" onclick="openMoveBgModal()" style="padding:9px 12px; background:#0a1520; border:1.5px solid rgba(0,210,255,0.4); color:var(--teal); border-radius:10px; font-weight:900; font-size:12px; cursor:pointer; display:flex; align-items:center; gap:7px; letter-spacing:0.5px;">‚úã Move Background</button>
    <div class="bg-slider-row">
        <span>Scale</span>
        <input type="range" id="bg-scale" min="50" max="300" value="100" oninput="applyBgTransform()">
        <input type="number" class="bg-num-input" id="bg-scale-num" min="50" max="300" value="100" oninput="document.getElementById('bg-scale').value=this.value; applyBgTransform()">
    </div>
    <div class="bg-slider-row">
        <span>Rotate</span>
        <input type="range" id="bg-rotate" min="-180" max="180" value="0" oninput="applyBgTransform()">
        <span class="val-label" id="bg-rotate-val">0¬∞</span>
    </div>
    <div class="bg-slider-row">
        <span>X Pos</span>
        <input type="range" id="bg-x" min="-50" max="50" value="0" oninput="applyBgTransform()">
        <input type="number" class="bg-num-input" id="bg-x-num" min="-50" max="50" value="0" oninput="document.getElementById('bg-x').value=this.value; applyBgTransform()">
    </div>
    <div class="bg-slider-row">
        <span>Y Pos</span>
        <input type="range" id="bg-y" min="-50" max="50" value="0" oninput="applyBgTransform()">
        <input type="number" class="bg-num-input" id="bg-y-num" min="-50" max="50" value="0" oninput="document.getElementById('bg-y').value=this.value; applyBgTransform()">
    </div>
    <div style="font-size:10px; font-weight:900; color:#555; text-transform:uppercase; letter-spacing:1px; margin-top:4px;">Filter</div>
    <div class="filter-row" id="filter-row"></div>
    <label style="display:flex; align-items:center; gap:8px; font-size:11px; font-weight:700; color:#666; cursor:pointer;">
        <input type="checkbox" id="bg-apply-all" style="accent-color:var(--accent);">
        Apply transform to all frames
    </label>
    <button onclick="resetBgTransform()" style="padding:8px; background:#222; color:#aaa; border:none; border-radius:8px; font-weight:700; cursor:pointer; font-size:11px;">Reset All</button>
</div>

<!-- ‚îÄ‚îÄ Multi-Frame Import Modal ‚îÄ‚îÄ -->
<div id="multi-import-modal" class="overlay-full">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <h2 style="margin:0; color:var(--accent); font-size:17px; letter-spacing:1px;">MULTI-FRAME IMPORT</h2>
            <span onclick="closeMultiImport()" style="cursor:pointer; font-size:22px; color:#555;">‚úï</span>
        </div>
        <p style="color:#666; font-size:12px; margin:0 0 12px;">Select multiple images ‚Äî each becomes a frame. All images should match your canvas ratio (<span id="multi-ratio-hint" style="color:var(--accent); font-weight:800;">1:1</span>).</p>
        <div class="multi-drop-zone" id="multi-drop-zone" onclick="document.getElementById('multi-file-input').click()">
            <div style="font-size:32px;">üñºÔ∏è</div>
            <strong>Tap to select images</strong>
            <p>Or drag &amp; drop files here</p>
            <input type="file" id="multi-file-input" multiple accept="image/*" style="display:none;" onchange="handleMultiFiles(this.files)">
        </div>
        <div id="multi-preview-grid"></div>
        <div class="multi-ratio-warning" id="multi-ratio-warning">‚ö†Ô∏è Some images have a different aspect ratio. They'll be cropped to fit your canvas.</div>
        <div style="display:flex; gap:10px; margin-top:16px;">
            <select id="multi-insert-mode" style="flex:1; padding:10px; background:#111; border:1px solid #333; color:white; border-radius:10px; font-size:12px; font-weight:700;">
                <option value="replace">Replace all frames</option>
                <option value="append">Append after current frame</option>
                <option value="from-current">Start from current frame</option>
            </select>
            <button id="multi-confirm-btn" onclick="confirmMultiImport()" style="flex:1; padding:10px; background:var(--accent); color:#000; border:none; border-radius:10px; font-weight:900; cursor:pointer;" disabled>Import Frames</button>
        </div>
    </div>
</div>

<!-- ‚îÄ‚îÄ TRANSFORM UI (draggable, resizable) ‚îÄ‚îÄ -->
<div id="transform-ui">
    <div id="transform-ui-header">
        <span style="font-size:12px; font-weight:900; color:var(--accent); cursor:grab;">TRANSFORM</span>
        <div style="display:flex; gap:6px; align-items:center;">
            <button onclick="flipHorizontal()" class="nav-btn" style="padding: 4px 8px;" title="Flip H">‚ÜîÔ∏è</button>
        </div>
    </div>
    
    <div class="slider-group transform-ui-collapsible" id="scale-slider-group">
        <div class="slider-group-row">
            <span>SCALE</span>
            <input type="range" id="size-slider" min="20" max="1000" value="200"
                oninput="document.getElementById('size-num').value=this.value; applyTransform && applyTransform()">
            <input type="number" id="size-num" class="slider-num-input" min="20" max="1000" value="200"
                oninput="document.getElementById('size-slider').value=Math.min(1000,Math.max(20,this.value||20)); applyTransform && applyTransform()">
        </div>
    </div>

    <div class="slider-group transform-ui-collapsible">
        <div class="slider-group-row">
            <span>ROTATE</span>
            <input type="range" id="rotate-slider" min="0" max="360" value="0"
                oninput="document.getElementById('rotate-num').value=this.value; applyTransform && applyTransform()">
            <input type="number" id="rotate-num" class="slider-num-input" min="0" max="360" value="0"
                oninput="document.getElementById('rotate-slider').value=Math.min(360,Math.max(0,this.value||0)); applyTransform && applyTransform()">
        </div>
    </div>

    <div id="text-settings" class="text-settings-row transform-ui-collapsible">
        <div class="slider-group">
            <span>FONT</span>
            <select id="font-family-select" class="text-input-field" onchange="updateTextProp('fontFamily', this.value)" style="flex:1;">
                <option value="'Inter', sans-serif">Standard</option>
                <option value="'Comic Neue', cursive">Comic Neue</option>
                <option value="'Bangers', cursive">Action Bangers</option>
                <option value="'Luckiest Guy', cursive">Luckiest Guy</option>
                <option value="'Permanent Marker', cursive">Marker</option>
                <option value="'Kalam', cursive">Kalam (Hand)</option>
                <option value="'Creepster', cursive">Horror</option>
                <option value="'Orbitron', sans-serif">Sci-Fi</option>
                <option value="'Rock Salt', cursive">Rock Salt</option>
                <option value="'Special Elite', cursive">Typewriter</option>
                <option value="'Fredoka One', cursive">Fredoka</option>
                <option value="'Boogaloo', cursive">Boogaloo</option>
                <option value="'Anton', sans-serif">Anton</option>
                <option value="'Chewy', cursive">Chewy</option>
                <option value="'Gloria Hallelujah', cursive">Gloria</option>
                <option value="'Shadows Into Light', cursive">Shadows</option>
                <option value="'Press Start 2P', cursive">Pixel</option>
                <option value="'Caveat', cursive">Caveat</option>
                <option value="'Bungee Inline', cursive">Bungee</option>
                <option value="'Righteous', cursive">Righteous</option>
                <option value="'Pacifico', cursive">Pacifico</option>
                <option value="'Abril Fatface', cursive">Abril Fatface</option>
                <option value="'Lilita One', cursive">Lilita One</option>
                <option value="'Audiowide', sans-serif">Audiowide</option>
                <option value="'Russo One', sans-serif">Russo One</option>
                <option value="'Black Ops One', cursive">Black Ops One</option>
                <option value="'Satisfy', cursive">Satisfy</option>
                <option value="'Dancing Script', cursive">Dancing Script</option>
                <option value="'Bebas Neue', cursive">Bebas Neue</option>
                <option value="'Alfa Slab One', cursive">Alfa Slab One</option>
            </select>
        </div>
        <div class="slider-group">
            <div class="slider-group-row">
                <span>SIZE</span>
                <input type="range" id="font-size-slider" min="10" max="120" value="28"
                    oninput="document.getElementById('font-size-num').value=this.value; updateTextProp('fontSize', this.value)">
                <input type="number" id="font-size-num" class="slider-num-input" min="10" max="120" value="28"
                    oninput="document.getElementById('font-size-slider').value=Math.min(120,Math.max(10,this.value||10)); updateTextProp('fontSize', this.value)">
            </div>
        </div>
        <div class="slider-group">
            <span>TEXT</span>
            <input type="text" id="text-content-input" class="text-input-field" style="flex:1;" placeholder="Edit text..." oninput="updateTextProp('content', this.value)">
        </div>
        <div id="bubble-style-change-row" style="display:none; flex-direction:column; gap:8px; border-top:1px solid #222; padding-top:10px;">
            <span style="font-size:10px;font-weight:900;color:#666;text-transform:uppercase;letter-spacing:1px;">Bubble Style</span>
            <div id="bubble-style-mini-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;"></div>
            <div style="display:flex;gap:6px;align-items:center;">
                <span style="font-size:10px;font-weight:900;color:#666;text-transform:uppercase;letter-spacing:1px;flex-shrink:0;">BG</span>
                <input type="color" id="bubble-bg-color" value="#ffffff" oninput="if(activeLayer){activeLayer.bubbleBg=this.value;render();}" style="flex:1;height:28px;border-radius:6px;border:1px solid #333;background:none;cursor:pointer;">
                <span style="font-size:10px;font-weight:900;color:#666;text-transform:uppercase;letter-spacing:1px;flex-shrink:0;">BORDER</span>
                <input type="color" id="bubble-border-color" value="#000000" oninput="if(activeLayer){activeLayer.bubbleBorderColor=this.value;render();}" style="flex:1;height:28px;border-radius:6px;border:1px solid #333;background:none;cursor:pointer;">
            </div>
        </div>
    </div>

    <div style="display:flex; flex-direction:column; gap:6px; margin-bottom:6px;" class="transform-ui-collapsible">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <span style="font-size:10px; font-weight:900; color:#666; text-transform:uppercase; letter-spacing:1px;">Position</span>
            <button id="position-collapse-btn" onclick="togglePositionArrows()" class="nav-btn" style="padding:2px 8px; font-size:11px;" title="Minimize arrows">‚¨á</button>
        </div>

        <!-- X / Y coordinate inputs -->
        <div style="display:flex; gap:6px;">
            <div style="flex:1; display:flex; flex-direction:column; gap:3px;">
                <span style="font-size:9px; font-weight:900; color:#555; text-transform:uppercase; letter-spacing:1px; text-align:center;">X</span>
                <input type="number" id="pos-x-input" class="slider-num-input" style="width:100%; box-sizing:border-box;"
                    placeholder="0"
                    oninput="if(activeLayer){ activeLayer.x = parseInt(this.value)||0; render(); }">
            </div>
            <div style="flex:1; display:flex; flex-direction:column; gap:3px;">
                <span style="font-size:9px; font-weight:900; color:#555; text-transform:uppercase; letter-spacing:1px; text-align:center;">Y</span>
                <input type="number" id="pos-y-input" class="slider-num-input" style="width:100%; box-sizing:border-box;"
                    placeholder="0"
                    oninput="if(activeLayer){ activeLayer.y = parseInt(this.value)||0; render(); }">
            </div>
            <div style="flex:1; display:flex; flex-direction:column; gap:3px;">
                <span style="font-size:9px; font-weight:900; color:#555; text-transform:uppercase; letter-spacing:1px; text-align:center;">Z</span>
                <div style="display:flex; gap:3px;">
                    <button onclick="moveLayerZ(1)"  class="nav-btn" style="flex:1; padding:4px 0; font-size:13px;" title="Bring Forward">‚Üë</button>
                    <button onclick="moveLayerZ(-1)" class="nav-btn" style="flex:1; padding:4px 0; font-size:13px;" title="Send Backward">‚Üì</button>
                </div>
            </div>
        </div>

        <div id="position-arrows-grid" style="display:grid; grid-template-columns:repeat(3,1fr); gap:5px;">
            <button onclick="alignLayer('left',   null)"   class="nav-btn" title="Align Left">‚¨Ö</button>
            <button onclick="alignLayer('center', null)"   class="nav-btn" title="Center H">‚Üî</button>
            <button onclick="alignLayer('right',  null)"   class="nav-btn" title="Align Right">‚û°</button>
            <button onclick="alignLayer(null,     'top')"  class="nav-btn" title="Align Top">‚¨Ü</button>
            <button onclick="centerLayer()"                class="nav-btn" title="Center Both" style="color:var(--accent); font-weight:900;">‚äï</button>
            <button onclick="alignLayer(null,     'bottom')" class="nav-btn" title="Align Bottom">‚¨á</button>
            <button style="grid-column:span 3;" onclick="alignLayer('center','middle')" class="nav-btn" title="Center Vertically">‚Üï Center V</button>
        </div>
    </div>
    <button id="edit-bg-btn" onclick="openBgPanel()" class="transform-ui-collapsible">üñºÔ∏è Edit Background</button>
    <div style="display:flex; gap:8px;" class="transform-ui-collapsible">
        <button onclick="deleteLayer()" style="flex:1; background:var(--danger); color:white; border:none; padding:10px; border-radius:10px; font-weight:bold; cursor:pointer;">DELETE</button>
        <button onclick="resetTransform()" style="flex:1; background:#333; color:white; border:none; padding:10px; border-radius:10px; font-weight:bold; cursor:pointer;">RESET</button>
        <button onclick="toggleTransform()" style="flex:2; border:none; background:var(--accent); color:white; padding:10px; border-radius:10px; font-weight:bold; cursor:pointer;">DONE</button>
    </div>

    <!-- Sprite blur section (only shown for img layers) -->
    <div id="sprite-blur-row" class="transform-ui-collapsible">
        <div style="font-size:10px; font-weight:900; color:#555; letter-spacing:1px; text-transform:uppercase;">Blur</div>
        <div class="blur-type-row">
            <button class="blur-type-btn" id="blur-none-btn" onclick="setSpriteBlur('none')">None</button>
            <button class="blur-type-btn" id="blur-soft-btn" onclick="setSpriteBlur('soft')">Soft Blur</button>
            <button class="blur-type-btn" id="blur-pixel-btn" onclick="setSpriteBlur('pixel')">Pixelate</button>
        </div>
        <div class="bg-slider-row" id="blur-amount-row" style="display:none;">
            <span>Amount</span>
            <input type="range" id="blur-amount" min="1" max="20" value="4" oninput="updateSpriteBlur()">
            <span class="val-label" id="blur-amount-val">4px</span>
        </div>
    </div>

    <!-- Sprite name tag (editor-only, private) -->
    <div id="sprite-nametag-row" style="display:none; border-top:1px solid #333; padding-top:10px; gap:8px; flex-direction:column;" class="transform-ui-collapsible">
        <div style="font-size:10px; font-weight:900; color:#555; letter-spacing:1px; text-transform:uppercase;">Private Name Tag</div>
        <div style="display:flex; gap:8px;">
            <input type="text" id="sprite-nametag-input" placeholder="Your label (only you see this)"
                style="flex:1; background:#111; border:1px solid #333; color:var(--accent); padding:8px 10px; border-radius:8px; font-size:11px; font-weight:700;"
                oninput="updateNameTag(this.value)">
            <button onclick="clearNameTag()" style="background:#222; border:none; color:#666; border-radius:8px; padding:8px 10px; cursor:pointer; font-size:11px;">Clear</button>
        </div>
        <button onclick="saveSpriteToPersonal()" style="padding:9px; background:#0a1a2a; border:1px solid var(--teal); color:var(--teal); border-radius:8px; font-weight:800; font-size:11px; cursor:pointer; width:100%;">üíæ Save to Your Sprites</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ LEGACY MENU DIVS (hidden, kept for JS compat) ‚îÄ‚îÄ -->
<div id="plus-menu" class="menu-popup">
    <button class="menu-item" onclick="openLibrary()">üé≠ Sprite Library</button>
    <button class="menu-item" onclick="triggerImport('object')">üì¶ Upload Object</button>
    <button class="menu-item" onclick="openBackgroundSource()">üñºÔ∏è Background Library</button>
    <button class="menu-item" onclick="triggerImport('bg')">üì∑ Local Background</button>
    <button class="menu-item" onclick="openMultiImport()">üóÇÔ∏è Multi-Frame Import</button>
    <hr style="width:100%; border:0; border-top:1px solid #333;">
    <button class="menu-item" onclick="openBubblePicker('speech')">üí¨ Speech Bubble</button>
    <button class="menu-item" onclick="openBubblePicker('thinking')">üí≠ Thinking Bubble</button>
    <button class="menu-item" onclick="addText('plain')">‚úçÔ∏è Plain Text</button>
</div>

<div id="layer-menu" class="menu-popup">
    <button class="menu-item" onclick="copyLayer()">üìÑ Copy Layer</button>
    <button class="menu-item" onclick="pasteLayer()">üìã Paste Layer</button>
    <button class="menu-item" onclick="deleteLayer()" style="color:var(--danger)">üóëÔ∏è Delete Selected</button>
    <div style="padding: 5px; font-size: 10px; color: #555; font-weight: 800; text-transform: uppercase;">Layers List</div>
    <div id="layer-list-container" style="max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px;"></div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     CANVA-STYLE APP SHELL
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="cc-app">

    <!-- TOP BAR -->
    <div id="top-bar">
        <button class="tb-btn" onclick="handleExit()">‚Üê Exit</button>
        <span class="tb-brand">COMICCORE</span>
        <div class="tb-sep"></div>
        <button class="tb-btn icon-btn" onclick="undo()" title="Undo (Ctrl+Z)">‚Ü©</button>
        <button class="tb-btn icon-btn" onclick="redo()" title="Redo (Ctrl+Y)">‚Ü™</button>

        <!-- Onion skin - icon toggle button -->
        <div id="onion-skin-control" style="display:none; gap:6px; align-items:center; background:rgba(255,255,255,0.04); padding:4px 8px; border-radius:8px; border:1px solid var(--border);">
            <button id="onion-icon-btn" onclick="toggleOnionSkin()" title="Onion Skin" style="background:none;border:none;cursor:pointer;padding:2px;display:flex;align-items:center;justify-content:center;border-radius:6px;transition:0.2s;">
                <img src="https://media.discordapp.net/attachments/1472088820584419450/1475988883614204018/Untitled52_20260224165244.png?ex=699f7d44&is=699e2bc4&hm=874e766336e8e7a12120d812f79cc4d607895bd29641ec44e3e89aefa80584a2&=&format=webp&quality=lossless" id="onion-icon-img" style="width:22px;height:22px;object-fit:contain;opacity:0.4;transition:opacity 0.2s, filter 0.2s;" alt="onion">
            </button>
            <input type="checkbox" id="onion-toggle" style="display:none;" onchange="render()">
            <input type="range" id="onion-opacity" min="0.1" max="0.7" step="0.1" value="0.3" oninput="render()" style="width:44px;">
        </div>

        <div class="tb-spacer"></div>

        <!-- Right actions -->
        <button class="tb-btn" onclick="saveOffline(false)">üíæ Save</button>
        <button class="tb-btn teal-btn" onclick="goToDrafts()">üìÇ Drafts</button>
        <div class="tb-sep"></div>
        <button class="tb-btn" onclick="openExportModal()">Export</button>
        <button class="tb-btn accent" onclick="openPublishModal()">Publish ‚Üë</button>

        <!-- Editor Prefs -->
        <button class="tb-btn icon-btn" onclick="toggleEditorPrefs()" title="Editor Preferences" style="font-size:13px;">‚öô</button>

        <!-- Hide UI -->
        <button class="tb-btn icon-btn" onclick="hideEditorUI()" title="Hide Interface (press H to restore)" style="font-size:13px; border-color:rgba(255,255,255,0.15);">üëÅ</button>

        <!-- Edit-action (ACTIONS) button ‚Äî now lives in sidebar; hidden from top bar -->
        <button id="edit-action-btn" style="display:none;" onclick="editCurrentSpriteAction()">üé¨ Actions</button>
    </div>

    <!-- WORK AREA -->
    <div id="work-area">

        <!-- LEFT SIDEBAR -->
        <div id="left-sidebar">
            <div id="sidebar-icons">

                <!-- Sprites -->
                <button class="sb-icon-btn" data-panel="sprites" onclick="toggleSidePanel('sprites')">
                    <span class="sb-icon"><img src="https://cdn.discordapp.com/attachments/1472088820584419450/1475305408464818337/IMG_1798.png?ex=699d00bb&is=699baf3b&hm=7564f665aa8167ab0088952702c05ee4dfe9b0446813b7e59552ac07ceea1f7d&" style="width:22px;height:22px;object-fit:contain;" alt="sprites"></span>Sprites
                </button>

                <!-- Add -->
                <button class="sb-icon-btn" data-panel="add" onclick="toggleSidePanel('add')">
                    <span class="sb-icon"><img src="https://media.discordapp.net/attachments/1472088820584419450/1475738268531294349/Untitled50_20260224001655.png?ex=699f3c9d&is=699deb1d&hm=3e952823d71a8451fd45b94c2a8e2f5b92e693d9ca2cb3e79869c1bb5a4945f2&=&format=webp&quality=lossless" class="sb-custom-icon" alt="add"></span>Add
                </button>

                <!-- Background -->
                <button class="sb-icon-btn" data-panel="background" onclick="toggleSidePanel('background')">
                    <span class="sb-icon"><img src="https://media.discordapp.net/attachments/1472088820584419450/1476014886181011567/Untitled.png?ex=699f957b&is=699e43fb&hm=e0df44f7e1e168ec27e6204f00a5f2b985e41df4020cbbf0865ac8ab79ede02c&=&format=webp&quality=lossless" class="sb-custom-icon" alt="background"></span>BG
                </button>

                <!-- Layers -->
                <button class="sb-icon-btn" data-panel="layers" onclick="toggleSidePanel('layers')">
                    <span class="sb-icon"><img src="https://media.discordapp.net/attachments/1472088820584419450/1475735904231620699/Untitled50_20260224000728.png?ex=699f3a69&is=699de8e9&hm=a81ad82f44163fe2a2afbe9046d3ed4b0a81f5cd69f3fdcba041a94084b12c2b&=&format=webp&quality=lossless" class="sb-custom-icon" alt="layers"></span>Layers
                </button>

                <div class="sb-divider"></div>

                <!-- Edit/Transform (opens floating panel) -->
                <button class="sb-icon-btn teal-icon" data-action="edit" onclick="sbEditAction()">
                    <span class="sb-icon"><img src="https://media.discordapp.net/attachments/1472088820584419450/1475740938910568600/Untitled50_20260224002716.png?ex=699f3f19&is=699ded99&hm=30eaf2b064268c3e30d7bea8fb0a52fcff552c42c5c1500ec8a89586b51cce0a&=&format=webp&quality=lossless" class="sb-custom-icon" alt="edit"></span>Edit
                </button>

                <!-- FX (opens floating panel) -->
                <button class="sb-icon-btn teal-icon" id="fx-btn" onclick="toggleFxPanel()">
                    <span class="sb-icon"><img src="https://media.discordapp.net/attachments/1472088820584419450/1475743931755925720/Untitled50_20260224003926.png?ex=699f41e3&is=699df063&hm=73efb25b11c45a422741bc6f84621181e94aa3d39f92e261ad2b5f836ddb3a66&=&format=webp&quality=lossless" class="sb-custom-icon" alt="fx"></span>FX
                </button>

                <!-- Actions (swap sprite action ‚Äî shown when sprite selected) -->
                <button class="sb-icon-btn teal-icon" id="sb-actions-btn" onclick="sbTriggerActions()" title="Change sprite action/pose">
                    <span class="sb-icon">üé¨</span>Actions
                </button>

            </div>

            <!-- SIDEBAR PANEL -->
            <div id="sidebar-panel">

                <!-- ‚îÄ‚îÄ Sprites panel ‚îÄ‚îÄ -->
                <div class="sp-content" id="sp-sprites">
                    <div class="sp-header">
                        Sprites
                        <span class="sp-close-btn" onclick="toggleSidePanel('sprites')">‚úï</span>
                    </div>
                    <input class="sp-search" id="sb-sprite-search" placeholder="Search sprites..." oninput="filterSidebarSprites()">
                    <div id="sb-sprite-grid">
                        <div class="sp-load-msg">Click to load sprites</div>
                    </div>
                </div>

                <!-- ‚îÄ‚îÄ Add panel ‚îÄ‚îÄ -->
                <div class="sp-content" id="sp-add">
                    <div class="sp-header">
                        ‚ûï Add Element
                        <span class="sp-close-btn" onclick="toggleSidePanel('add')">‚úï</span>
                    </div>
                    <div class="sp-add-scroll">
                        <div class="sp-section-label">Text</div>
                        <button class="sp-action-btn" onclick="openBubblePicker('speech'); toggleSidePanel('add')">
                            <span class="sp-action-icon">üí¨</span> Speech Bubble
                        </button>
                        <button class="sp-action-btn" onclick="openBubblePicker('thinking'); toggleSidePanel('add')">
                            <span class="sp-action-icon">üí≠</span> Thinking Bubble
                        </button>
                        <button class="sp-action-btn" onclick="addText('plain'); toggleSidePanel('add')">
                            <span class="sp-action-icon">‚úçÔ∏è</span> Plain Text
                        </button>
                        <button class="sp-action-btn" onclick="addSubtitle(); toggleSidePanel('add')">
                            <span class="sp-action-icon">üìã</span> Subtitle Bar
                        </button>

                        <div class="sp-section-label">Media</div>
                        <button class="sp-action-btn" onclick="toggleSidePanel('sprites')">
                            <span class="sp-action-icon">üé≠</span> Sprite Library
                        </button>
                        <button class="sp-action-btn" onclick="triggerImport('object'); toggleSidePanel('add')">
                            <span class="sp-action-icon">üì¶</span> Upload Image
                        </button>
                        <button class="sp-action-btn" onclick="openMultiImport(); toggleSidePanel('add')">
                            <span class="sp-action-icon">üóÇ</span> Multi-Frame Import
                        </button>
                    </div>
                </div>

                <!-- ‚îÄ‚îÄ Background panel ‚îÄ‚îÄ -->
                <div class="sp-content" id="sp-background">
                    <div class="sp-header">
                        üñº Background
                        <span class="sp-close-btn" onclick="toggleSidePanel('background')">‚úï</span>
                    </div>
                    <div class="sp-add-scroll">
                        <div class="sp-section-label">Source</div>
                        <button class="sp-action-btn" onclick="openBackgroundSource(); toggleSidePanel('background')">
                            <span class="sp-action-icon">üñº</span> Background Library
                        </button>
                        <button class="sp-action-btn" onclick="triggerImport('bg'); toggleSidePanel('background')">
                            <span class="sp-action-icon">üì∑</span> Upload Local Image
                        </button>
                        <div class="sp-section-label">Adjust</div>
                        <button class="sp-action-btn" onclick="openBgPanel(); toggleSidePanel('background')">
                            <span class="sp-action-icon">üéö</span> Edit BG Transform & Filters
                        </button>
                    </div>
                </div>

                <!-- ‚îÄ‚îÄ Layers panel ‚îÄ‚îÄ -->
                <div class="sp-content" id="sp-layers">
                    <div class="sp-header">
                        üìö Layers
                        <span class="sp-close-btn" onclick="toggleSidePanel('layers')">‚úï</span>
                    </div>
                    <div id="sb-layer-actions">
                        <button class="sb-lay-btn" onclick="sbCopyLayer()">üìÑ Copy</button>
                        <button class="sb-lay-btn" onclick="sbPasteLayer()">üìã Paste</button>
                        <button class="sb-lay-btn" onclick="toggleSelectedLayerLock()">üîí Lock</button>
                        <button class="sb-lay-btn danger" onclick="deleteLayer()">üóë Del</button>
                    </div>
                    <div id="sb-layer-list"></div>
                </div>

            </div>
        </div>

        <!-- CANVAS VIEWPORT -->
        <div id="viewport">
            <div id="canvas-container">
                <canvas id="onion-skin-canvas" width="900" height="900"></canvas>
                <div id="comic-frame" onclick="deselectLayer(event)">
                    <div id="bg-drag-overlay"><div class="drag-hint">‚úã Drag to pan background</div></div>
                </div>
                <div id="global-frame-indicator">FRAME 1</div>
            </div>
            <div id="zoom-hud">
                <span id="zoom-pct">100%</span>
                <button onclick="vpResetZoom()">Reset</button>
            </div>
        </div>

    </div><!-- /work-area -->

    <!-- FRAME STRIP -->
    <div id="frame-strip">
        <div id="fs-nav">
            <div class="fs-nav-row">
                <button class="fs-nav-btn" onclick="goToFrame(0)" title="First">‚èÆ</button>
                <button class="fs-nav-btn" onclick="prevFrame()" title="Prev">‚óÄ</button>
                <button class="fs-nav-btn" onclick="nextFrame()" title="Next">‚ñ∂</button>
                <button class="fs-nav-btn" onclick="goToFrame(frames.length-1)" title="Last">‚è≠</button>
            </div>
            <span id="frame-label" style="font-size:10px; font-weight:900; color:var(--accent); letter-spacing:1px;">1 / 1</span>
        </div>
        <div id="thumb-container"></div>
        <div id="fs-actions">
            <div class="fs-act-row">
                <button class="fs-act-btn add-frame" onclick="addFrame()">+ New Frame</button>
                <button class="fs-act-btn" onclick="duplicateFrame()">‚ßâ Dup</button>
            </div>
            <div class="fs-act-row">
                <button class="fs-act-btn" onclick="copyCurrentFrame()">üéû Copy</button>
                <button class="fs-act-btn" onclick="pasteFrame()">üì• Paste</button>
                <button class="fs-act-btn danger" onclick="deleteFrame()">üóë Del</button>
            </div>
        </div>
    </div>

</div><!-- /cc-app -->

<!-- HIDDEN LEGACY FRAME DRAWER (needed by JS) -->
<div id="frame-drawer" style="display:none !important;"></div>

<!-- UI Reveal Button (shown when UI is hidden) -->
<button id="ui-reveal-btn" onclick="showEditorUI()" title="Show Interface">‚Ä∫</button>

<!-- Editor Preferences Panel -->
<div id="editor-prefs-panel">
    <div class="prefs-title">
        <span>‚öô Editor Preferences</span>
        <span style="cursor:pointer;color:#444;" onclick="closeEditorPrefs()">‚úï</span>
    </div>
    <div style="display:flex; flex-direction:column; gap:10px;">
        <div style="font-size:10px; font-weight:800; color:#555; text-transform:uppercase; letter-spacing:1px;">Selection Outline Opacity</div>
        <div style="display:flex; align-items:center; gap:10px;">
            <input type="range" id="sel-opacity-slider" min="0" max="100" value="100" style="flex:1;"
                oninput="updateSelectionOpacity(this.value)">
            <span id="sel-opacity-val" style="font-size:11px; font-weight:800; color:var(--accent); width:36px; text-align:right;">100%</span>
        </div>
        <div style="font-size:10px; color:#444; font-weight:600; line-height:1.4;">Lower this to make the orange selection box less visible. Saved automatically.</div>
    </div>
</div>

<input type="file" id="img-input" hidden accept="image/*">
<!-- FIX 2: cover-input now has onchange handler so the cropper fires correctly for cover uploads -->
<input type="file" id="cover-input" hidden accept="image/*" onchange="handleCoverInput(event)">

<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

<script>
    const _supabase = supabase.createClient('https://mmycqeejhguzhtzkyjaj.supabase.co', 'sb_publishable_8Du2GAcH5oBeiHWe-1e0Fg_XtSub2QE');

    let frames = [{ layers: [], background: '#ffffff' }];
    let currentIdx = 0;
    let history = []; 
    let redoStack = [];
    let activeLayer = null;
    let selectedLayers = []; // multi-select for FX
    let cropper = null;
    let currentImportType = null;
    let hasUnsavedChanges = false;
    let activeDraftId = null;
    let editingComicId = null; // set when loading a published comic for editing
    let finalCoverBase64 = null;
    let frameClipboard = null;

    const canvas = document.getElementById('comic-frame');
    const onionCanvas = document.getElementById('onion-skin-canvas');
    const onionCtx = onionCanvas.getContext('2d');

    // FIX 2: Dedicated cover input handler ‚Äî opens cropper locked to 1:1 square
    function handleCoverInput(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            currentImportType = 'cover';
            document.getElementById('crop-modal').style.display = 'flex';
            const target = document.getElementById('crop-target');
            target.src = ev.target.result;
            if (cropper) cropper.destroy();
            cropper = new Cropper(target, { aspectRatio: 1, viewMode: 1 });
        };
        reader.readAsDataURL(file);
        // Reset input so the same file can be re-selected if needed
        e.target.value = '';
    }

    function openBackgroundSource() {
        // Preserve ratio so cropper uses correct aspect ratio on return
        if (canvasRatio) {
            localStorage.setItem('cc-bg-ratio-filter', JSON.stringify(canvasRatio));
            localStorage.setItem('cc-active-ratio', JSON.stringify(canvasRatio));
        }
        // Preserve all frames + current index so nothing resets on return
        localStorage.setItem('cc-pending-frames', JSON.stringify({ frames, currentIdx }));
        location.href = 'backgroundsource.html';
    }

        // ‚îÄ‚îÄ Helper: apply a pending background after any load path ‚îÄ‚îÄ
        function applyPendingBg(pendingBg, pendingBgId) {
            // pending_bg_id: library image referenced by ID (avoids localStorage size limits)
            if (pendingBgId) {
                localStorage.removeItem('pending_bg_id');
                currentImportType = 'bg';
                _supabase.from('backgrounds_library').select('image_data').eq('id', pendingBgId).single().then(({ data }) => {
                    if (data && data.image_data) showBgImportChoice(data.image_data);
                });
                return;
            }
            if (!pendingBg) return;
            localStorage.removeItem('pending_background');
            const isImageData = pendingBg.startsWith('http') || pendingBg.startsWith('data:image');
            if (isImageData) {
                // Show Crop / Fixed Import choice instead of going straight to cropper
                currentImportType = 'bg';
                showBgImportChoice(pendingBg);
            } else {
                // Solid color or CSS gradient ‚Äî apply directly
                frames[currentIdx].background = pendingBg;
                render();
            }
        }

        window.onload = function() {
        // ‚îÄ‚îÄ MOBILE REDIRECT: send touch devices to create-mobile.html ‚îÄ‚îÄ
        var isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent) || window.innerWidth <= 768;
        if (isMobile) {
            // edit_comic_id is already in localStorage ‚Äî create-mobile picks it up
            location.replace('create-mobile.html');
            return;
        }
        // FPS counter
        if (localStorage.getItem('cc-show-fps') === 'true') {
            const fpsDisplay = document.createElement('div');
            fpsDisplay.style.cssText = 'position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.7);color:#00ff66;font-family:monospace;font-size:12px;font-weight:700;padding:4px 10px;border-radius:6px;z-index:9999;pointer-events:none;';
            fpsDisplay.innerText = '-- FPS';
            document.body.appendChild(fpsDisplay);
            let lastTime = performance.now(), frameCount = 0;
            function tick() {
                frameCount++;
                const now = performance.now();
                if (now - lastTime >= 1000) { fpsDisplay.innerText = frameCount + ' FPS'; frameCount = 0; lastTime = now; }
                requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);
        }

        // Grab pending bg keys EARLY ‚Äî before any early returns wipe them
        const pendingBg    = localStorage.getItem('pending_background');
        const pendingBgId  = localStorage.getItem('pending_bg_id');

        const resumeId = localStorage.getItem('active_draft_id');
        if (resumeId) {
            const drafts = JSON.parse(localStorage.getItem('comic_drafts') || '[]');
            const found = drafts.find(d => d.id == resumeId);
            if (found) {
                frames = found.data;
                activeDraftId = resumeId;
                const savedRatio = found.ratio || { w: 1, h: 1 };
                setRatio(savedRatio.w, savedRatio.h);
                // ‚úÖ FIX: process pending background even when resuming a draft
                applyPendingBg(pendingBg, pendingBgId);
                return;
            }
        }

        // ‚îÄ‚îÄ Load published comic for editing (triggered from reader EDIT button) ‚îÄ‚îÄ
        const editComicId = localStorage.getItem('edit_comic_id');
        if (editComicId) {
            localStorage.removeItem('edit_comic_id');
            editingComicId = editComicId;
            document.getElementById('publish-btn').innerText = 'UPDATE';
            const banner = document.createElement('div');
            banner.id = 'edit-banner';
            banner.style.cssText = 'position:fixed;top:0;left:50%;transform:translateX(-50%);background:#00d2ff;color:#000;padding:5px 20px;font-size:11px;font-weight:900;border-radius:0 0 10px 10px;z-index:9999;letter-spacing:1px;pointer-events:none;';
            banner.innerText = '‚úèÔ∏è EDITING PUBLISHED COMIC';
            document.body.appendChild(banner);
            _supabase.from('comics').select('*').eq('id', editComicId).single().then(({ data, error }) => {
                if (error || !data) { alert('Could not load comic for editing.'); return; }
                frames = data.data || data.frames || [];
                const r = data.canvas_ratio || { w: 1, h: 1 };
                setRatio(r.w, r.h);
                document.getElementById('pub-title').value = data.title || '';
                document.getElementById('pub-tags').value = (data.tags || []).join(', ');
                document.getElementById('pub-desc').value = data.description || '';
                if (data.cover) {
                    finalCoverBase64 = data.cover;
                    const img = document.getElementById('final-cover-img');
                    img.src = data.cover; img.style.display = 'block';
                    document.getElementById('cover-label').style.display = 'none';
                }
                // ‚úÖ FIX: process pending background even when loading a comic for editing
                applyPendingBg(pendingBg, pendingBgId);
            });
            return;
        }

        // ‚îÄ‚îÄ Returning from backgroundsource.html ‚îÄ‚îÄ
        const pendingFrames = localStorage.getItem('cc-pending-frames');

        if (pendingFrames) {
            // Restore exactly what was there before navigating away
            localStorage.removeItem('cc-pending-frames');
            const saved = JSON.parse(pendingFrames);
            frames     = saved.frames;
            currentIdx = saved.currentIdx;
        }

        // Restore ratio: prefer new choice, fall back to active ratio, then 1:1
        const storedNew    = localStorage.getItem('cc-new-comic-ratio');
        const storedActive = localStorage.getItem('cc-active-ratio');
        if (storedNew) {
            const r = JSON.parse(storedNew);
            localStorage.removeItem('cc-new-comic-ratio');
            setRatio(r.w, r.h);
        } else if (storedActive) {
            const r = JSON.parse(storedActive);
            setRatio(r.w, r.h);   // keep cc-active-ratio for future navigations
        } else {
            setRatio(1, 1);
        }

        // Apply background chosen from backgroundsource.html
        applyPendingBg(pendingBg, pendingBgId);
    };

    function deselectLayer(e) {
        if(e.target === canvas) {
            activeLayer = null;
            closeFtbPanel();
            hideFloatToolbar();
            document.getElementById('edit-action-btn').style.display = 'none';
            document.getElementById('transform-ui').style.display = 'none';
            document.getElementById('text-settings').style.display = 'none';
            document.getElementById('onion-skin-control').style.display = 'none';
            const actBtn = document.getElementById('sb-actions-btn');
            if (actBtn) actBtn.classList.remove('active');
            render();
        }
    }

    function startDrag(e, layer) {
        saveState();
        let startX = e.clientX - layer.x;
        let startY = e.clientY - layer.y;
        let moved = false;
        const move = (me) => {
            if (!moved) { moved = true; closeFtbPanel(); hideFloatToolbar(); }
            const canvasRect = canvas.getBoundingClientRect();
            const rawX = me.clientX - startX;
            const rawY = me.clientY - startY;
            if (layer.type === 'img') {
                // Images can go up to halfway outside the frame on any edge
                const layerW = layer.w || 100;
                const layerH = layer.h || layerW;
                const halfW = layerW / 2;
                const halfH = layerH / 2;
                layer.x = Math.min(Math.max(rawX, -halfW), canvasRect.width - halfW);
                layer.y = Math.min(Math.max(rawY, -halfH), canvasRect.height - halfH);
            } else {
                // Text, bubbles, subtitles ‚Äî completely free movement, no clamping
                layer.x = rawX;
                layer.y = rawY;
            }
            render();
        };
        const up = () => { 
            window.removeEventListener('mousemove', move);
            window.removeEventListener('mouseup', up);
            // Re-show toolbar after drag ends if it's a text layer
            if (moved && ['text','bubble','thinking','subtitle'].includes(layer.type)) {
                setTimeout(() => showFloatToolbar(layer), 30);
            }
        };
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', up);
    }

    function moveLayerZ(dir) {
        if(!activeLayer) return;
        saveState();
        const layers = frames[currentIdx].layers;
        const idx = layers.findIndex(l => l.id === activeLayer.id);
        if(dir > 0 && idx < layers.length - 1) [layers[idx], layers[idx+1]] = [layers[idx+1], layers[idx]];
        else if(dir < 0 && idx > 0) [layers[idx], layers[idx-1]] = [layers[idx-1], layers[idx]];
        render();
    }

    function resetTransform() {
        if(!activeLayer) return;
        saveState();
        activeLayer.w = 250; activeLayer.rotation = 0; activeLayer.flipped = false;
        render();
    }

    function updateTextProp(prop, value) {
        if (activeLayer && (activeLayer.type === 'bubble' || activeLayer.type === 'thinking' || activeLayer.type === 'text')) {
            activeLayer[prop] = (prop === 'fontSize') ? parseInt(value) : value;
            render();
        }
    }

    async function openLibrary() {
        const grid = document.getElementById('library-grid');
        document.getElementById('library-modal').style.display = 'flex';
        toggleMenu('plus-menu');

        // Use already-loaded sidebar metadata if available, otherwise fetch metadata only
        const meta = sidebarSprites || sbLoadMetaCache();
        if (meta && meta.length) {
            renderLibraryGrid(grid, meta);
        } else {
            grid.innerHTML = "<p style='color:white; font-size:12px;'>Loading...</p>";
            const { data } = await _supabase.from('sprites_library')
                .select('id, name, tags, creator, created_at')
                .order('created_at', { ascending: false });
            sidebarSprites = data || [];
            sbSaveMetaCache(sidebarSprites);
            renderLibraryGrid(grid, sidebarSprites);
        }
    }

    function renderLibraryGrid(grid, sprites) {
        grid.innerHTML = '';
        sprites.forEach(pack => {
            const div = document.createElement('div');
            div.className = 'action-option';
            const cachedSrc = pack.image_data || sbGetImg(pack.id);
            div.innerHTML = cachedSrc
                ? `<img src="${cachedSrc}"><strong>${pack.name}</strong>`
                : `<div style="width:100%;aspect-ratio:1;background:linear-gradient(90deg,#1e1e1e 25%,#2a2a2a 50%,#1e1e1e 75%);background-size:200% 100%;animation:sb-shimmer 1.4s infinite;border-radius:6px;"></div><strong>${pack.name}</strong>`;
            div.onclick = async () => {
                const hasFull = pack.image_data && pack.actions !== undefined;
                if (hasFull) { closeLibrary(); openActionModal(pack); return; }
                div.style.opacity = '0.5';
                const full = await sbFetchFull(pack.id);
                div.style.opacity = '';
                if (full) { closeLibrary(); openActionModal({ ...pack, ...full }); }
            };
            // Lazy-load image if not cached
            if (!cachedSrc) {
                const observer = new IntersectionObserver(entries => {
                    if (!entries[0].isIntersecting) return;
                    observer.disconnect();
                    sbFetchFull(pack.id).then(full => {
                        if (!full) return;
                        const img = div.querySelector('div');
                        if (img) { const el = document.createElement('img'); el.src = full.image_data; img.replaceWith(el); }
                    });
                }, { root: grid });
                observer.observe(div);
            }
            grid.appendChild(div);
        });
    }

    function openActionModal(pack, isEditing = false) {
        document.getElementById('pack-title').innerText = pack.name;
        const grid = document.getElementById('action-selector-list');
        grid.innerHTML = "";
        const main = createActionOption(pack.image_data, "Default");
        main.onclick = () => handleActionSelect(pack.image_data, pack, isEditing);
        grid.appendChild(main);
        
        let actions = pack.actions;
        if (typeof actions === 'string') try { actions = JSON.parse(actions); } catch(e) { actions = {}; }
        const items = Array.isArray(actions) ? actions.map((img, i) => [`Action ${i+1}`, img]) : Object.entries(actions || {});
        items.forEach(([name, img]) => {
            const opt = createActionOption(img, name);
            opt.onclick = () => handleActionSelect(img, pack, isEditing);
            grid.appendChild(opt);
        });
        document.getElementById('action-modal').style.display = 'flex';
    }

    function handleActionSelect(img, pack, isEditing) {
        if(isEditing) { saveState(); activeLayer.src = img; }
        else addSpriteToCanvas(img, pack);
        closeActionModal(); render();
    }

    function addSpriteToCanvas(src, pack) {
        saveState();
        const nl = { type: 'img', src, w: 200, x: 100, y: 100, rotation: 0, flipped: false, packData: pack, id: Date.now() };
        frames[currentIdx].layers.push(nl);
        activeLayer = nl;
    }

    function editCurrentSpriteAction() { if (activeLayer?.packData) openActionModal(activeLayer.packData, true); }

    // Helper: detect if a data URL or src is a GIF/animated image that needs <img> rendering
    function isAnimatedBg(src) {
        if (!src) return false;
        if (src.startsWith('data:image/gif')) return true;
        if (src.startsWith('data:image/webp')) return true;
        if (src.startsWith('data:image/apng')) return true;
        const lower = src.toLowerCase();
        return lower.includes('.gif') || (lower.includes('.webp') && !lower.includes('static'));
    }

    function render() {
        // Clear canvas children EXCEPT the bg-drag-overlay and onion canvas
        // We rebuild everything including #cc-bg-layer
        const dragOverlay = document.getElementById('bg-drag-overlay');
        canvas.innerHTML = "";
        // Re-add drag overlay (innerHTML cleared it)
        canvas.appendChild(dragOverlay);

        const f = frames[currentIdx];
        const bg = f.background || '#ffffff';

        // Live-sync X/Y inputs if transform panel is open and a layer is active
        if (activeLayer && document.getElementById('transform-ui').style.display === 'flex') {
            const xEl = document.getElementById('pos-x-input');
            const yEl = document.getElementById('pos-y-input');
            if (xEl && document.activeElement !== xEl) xEl.value = Math.round(activeLayer.x) || 0;
            if (yEl && document.activeElement !== yEl) yEl.value = Math.round(activeLayer.y) || 0;
        }

        // Classify the background value
        const isImageUrl = bg.startsWith('http') || bg.startsWith('data:image');
        const isGradient = bg.startsWith('linear-gradient') || bg.startsWith('radial-gradient');
        const isAnimated = isAnimatedBg(bg);

        // Always reset canvas-level bg/filter ‚Äî filter is ONLY on the bg-layer div
        canvas.style.backgroundColor = '#ffffff';
        canvas.style.backgroundImage = 'none';
        canvas.style.backgroundSize  = '';
        canvas.style.backgroundPosition = '';
        canvas.style.filter = ''; // NEVER set filter on canvas root ‚Äî sprites would inherit it

        // Apply background transform + filter settings
        const s = f.bgSettings || {};
        const scale  = s.scale  ?? 100;
        const rotate = s.rotate ?? 0;
        const xOff   = s.x      ?? 0;
        const yOff   = s.y      ?? 0;
        const filter = s.filter || 'none';
        const filterCSS = filter === 'none' ? '' : filter;

        // ‚îÄ‚îÄ Build dedicated bg-layer div ‚îÄ‚îÄ
        const bgLayer = document.createElement('div');
        bgLayer.id = 'cc-bg-layer';
        bgLayer.style.cssText = 'position:absolute;inset:0;z-index:0;pointer-events:none;overflow:hidden;';
        if (filterCSS) bgLayer.style.filter = filterCSS;

        if (isImageUrl) {
            canvas.style.backgroundColor = 'transparent';
            if (isAnimated) {
                // GIF/WebP animated: use <img> so animation plays
                const img = document.createElement('img');
                img.className = 'bg-gif';
                img.src = bg;
                const scaleF = scale / 100;
                const posX = 50 + xOff;
                const posY = 50 + yOff;
                img.style.cssText = `position:absolute;width:${scale}%;height:auto;min-height:${scale}%;
                    object-fit:cover;pointer-events:none;
                    left:${posX}%;top:${posY}%;
                    transform:translate(-50%,-50%) rotate(${rotate}deg);
                    transform-origin:center center;`;
                bgLayer.appendChild(img);
            } else if (rotate !== 0) {
                const bgDiv = document.createElement('div');
                bgDiv.style.cssText = `position:absolute;top:-60%;left:-60%;width:220%;height:220%;
                    background:url(${bg});background-size:${scale * 2.2}%;
                    background-position:center;background-repeat:no-repeat;
                    transform:rotate(${rotate}deg);transform-origin:center center;`;
                bgLayer.appendChild(bgDiv);
            } else {
                bgLayer.style.background = `url(${bg})`;
                bgLayer.style.backgroundSize = scale + '%';
                bgLayer.style.backgroundPosition = (50 + xOff) + '% ' + (50 + yOff) + '%';
                bgLayer.style.backgroundRepeat = 'no-repeat';
            }
        } else if (isGradient) {
            canvas.style.backgroundColor = 'transparent';
            if (rotate !== 0) {
                const bgDiv = document.createElement('div');
                bgDiv.style.cssText = `position:absolute;top:-60%;left:-60%;width:220%;height:220%;
                    background:${bg};background-size:cover;background-position:center;
                    transform:rotate(${rotate}deg);transform-origin:center center;`;
                bgLayer.appendChild(bgDiv);
            } else {
                bgLayer.style.background = bg;
                bgLayer.style.backgroundSize = 'cover';
            }
        } else {
            // Solid color
            canvas.style.backgroundColor = bg;
        }

        canvas.insertBefore(bgLayer, canvas.firstChild);

        const onionOn = document.getElementById('onion-toggle').checked;
        if(onionOn && currentIdx > 0) {
            onionCanvas.style.display = 'block';
            onionCtx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
            const prevFrameData = frames[currentIdx - 1];
            onionCtx.globalAlpha = document.getElementById('onion-opacity').value;
            prevFrameData.layers.forEach(l => {
                if(l.type === 'img') {
                    const img = new Image();
                    img.src = l.src;
                    const draw = () => {
                        onionCtx.save();
                        const h = l.w * (img.naturalHeight / img.naturalWidth);
                        onionCtx.translate(l.x + l.w/2, l.y + h/2);
                        onionCtx.rotate((l.rotation || 0) * Math.PI / 180);
                        if(l.flipped) onionCtx.scale(-1, 1);
                        onionCtx.drawImage(img, -l.w/2, -h/2, l.w, h);
                        onionCtx.restore();
                    };
                    if(img.complete) draw(); else img.onload = draw;
                }
            });
        } else {
            onionCanvas.style.display = 'none';
        }

        f.layers.forEach((l) => {
            let el;
            if(l.type === 'img') { 
                el = document.createElement('img'); 
                el.src = l.src;
            } else {
                el = document.createElement('div');
                const fs = l.fontSize || 28;
                const ff = l.fontFamily || "'Inter', sans-serif";
                if(l.type === 'bubble' || l.type === 'thinking') {
                    const isThinking = l.type === 'thinking';
                    const textColor = l.color || '#000';
                    const boldW = l.bold ? '900' : '800';
                    const italicS = l.italic ? 'italic' : 'normal';
                    const alignS = l.align || 'center';
                    const decoB = [l.underline ? 'underline' : '', l.strikethrough ? 'line-through' : ''].filter(Boolean).join(' ') || 'none';
                    // Determine style class
                    const bStyle = l.bubbleStyle || (isThinking ? 'cloud' : 'round');
                    const isCloud = bStyle === 'cloud';
                    const thoughtDots = isCloud ? '<div class="thought-dot-1"></div><div class="thought-dot-2"></div><div class="thought-dot-3"></div>' : '';
                    const showTail = !['spiky','shout','electric','narrator','cloud'].includes(bStyle);
                    // Border/bg overrides stored on layer
                    const bubBorder = l.bubbleBorderColor || '#000';
                    const bubBg     = l.bubbleBg || (bStyle === 'shout' ? '#ffeb3b' : bStyle === 'narrator' ? '#fffde7' : '#fff');
                    const inlineStyle = `--bubble-border:${bubBorder}; --bubble-bg:${bubBg}; border-color:${bubBorder}; background:${bubBg};`;
                    el.innerHTML = `
                        <div class="speech-bubble bubble-style-${bStyle}" style="${inlineStyle} font-size:${fs}px; font-family:${ff}; color:${textColor}; font-weight:${boldW}; font-style:${italicS}; text-align:${alignS}; text-decoration:${decoB};">
                            ${l.content}
                            ${showTail ? '<div class="bubble-tail"></div>' : ''}
                            ${thoughtDots}
                        </div>`;
                } else if (l.type === 'subtitle') {
                    const nameColor   = l.nameColor  || '#ff9500';
                    const dialogColor = l.color || '#111';
                    const alignS  = l.align  || 'left';
                    const boldW   = l.bold   ? '900' : '700';
                    const italicS = l.italic ? 'italic' : 'normal';
                    el.innerHTML = `
                        <div style="background:${nameColor};color:#fff;font-size:${Math.max(10,fs*0.55)}px;font-weight:900;font-family:${ff};padding:3px 10px;border-radius:5px 5px 0 0;letter-spacing:1px;text-transform:uppercase;line-height:1.5;text-align:${alignS};white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${l.characterName || 'CHARACTER'}</div>
                        <div style="background:rgba(255,255,255,0.96);color:${dialogColor};font-size:${fs}px;font-weight:${boldW};font-style:${italicS};font-family:${ff};padding:6px 10px;border-radius:0 0 5px 5px;text-align:${alignS};line-height:1.4;border:1.5px solid rgba(0,0,0,0.1);border-top:none;">${l.content || 'Dialogue...'}</div>
                    `;
                    Object.assign(el.style, {
                        width: l.w + 'px',
                        borderRadius: '5px',
                        overflow: 'visible',
                        boxShadow: activeLayer === l ? '0 0 0 2px var(--accent)' : '0 2px 8px rgba(0,0,0,0.2)',
                    });
                } else {
                    el.innerHTML = l.content;
                    const decorations = [];
                    if (l.underline)     decorations.push('underline');
                    if (l.strikethrough) decorations.push('line-through');
                    Object.assign(el.style, {
                        color: l.color || "#000",
                        fontWeight: l.bold ? "900" : "700",
                        fontStyle: l.italic ? "italic" : "normal",
                        textDecoration: decorations.length ? decorations.join(' ') : 'none',
                        textAlign: l.align || "left",
                        fontSize: fs + "px",
                        fontFamily: ff,
                        lineHeight: "1.3"
                    });
                }
            }
            // Apply FX: blur, layer filter, opacity
            const blurCSS   = getSpriteFilterCSS(l);
            const lfCSS     = (l.layerFilter && l.layerFilter !== 'none') ? l.layerFilter : '';
            const combinedFilter = [blurCSS, lfCSS].filter(Boolean).join(' ') || '';
            if (combinedFilter) el.style.filter = combinedFilter;
            if (l.opacity != null && l.opacity !== 100) el.style.opacity = l.opacity / 100;
            // Multi-select highlight
            const isMultiSel = selectedLayers.some(s => s.id === l.id);
            el.className = 'layer' + (activeLayer && activeLayer.id === l.id ? ' active' : '') + (isMultiSel ? ' layer-item-sel' : '');
            Object.assign(el.style, { width: l.w + 'px', left: l.x + 'px', top: l.y + 'px', transform: `rotate(${l.rotation || 0}deg) scaleX(${l.flipped ? -1 : 1})` });
            // Locked layer: show dim overlay and lock badge
            if (l.locked) {
                el.style.opacity = (l.opacity != null ? l.opacity / 100 : 1) * 0.6 + '';
                el.style.cursor = 'default';
                const lockBadge = document.createElement('div');
                lockBadge.style.cssText = 'position:absolute;top:2px;right:2px;font-size:10px;background:rgba(0,0,0,0.6);border-radius:3px;padding:1px 3px;pointer-events:none;z-index:10;';
                lockBadge.innerText = 'üîí';
                el.style.position = 'relative';
                el.appendChild(lockBadge);
            }
            
            // Private name tag overlay (editor-only, not in export)
            if (l.nameTag && activeLayer && activeLayer.id === l.id) {
                const tag = document.createElement('div');
                tag.className = 'sprite-nametag';
                tag.innerText = l.nameTag;
                el.style.position = 'absolute';
                // We wrap in a container to properly position the tag
                const wrapper = document.createElement('div');
                wrapper.className = 'layer' + (activeLayer && activeLayer.id === l.id ? ' active' : '');
                wrapper.style.cssText = `width:${l.w}px; left:${l.x}px; top:${l.y}px; transform:rotate(${l.rotation || 0}deg) scaleX(${l.flipped ? -1 : 1}); position:absolute;`;
                el.className = '';
                el.style.position = 'relative';
                el.style.left = ''; el.style.top = ''; el.style.width = '100%';
                wrapper.appendChild(el);
                wrapper.appendChild(tag);
                wrapper.onmousedown = (e) => {
                    e.stopPropagation();
                    if (l.locked) return; // Locked layers cannot be selected
                    activeLayer = l;
                    // Highlight Actions sidebar button when a sprite with packData is selected
                    const actBtn = document.getElementById('sb-actions-btn');
                    if (actBtn) actBtn.classList.toggle('active', !!l.packData);
                    document.getElementById('edit-action-btn').style.display = 'none';
                    document.getElementById('onion-skin-control').style.display = 'flex';
                    render();
                    if (['text','bubble','thinking','subtitle'].includes(l.type)) {
                        setTimeout(() => showFloatToolbar(l), 20);
                    } else { hideFloatToolbar(); }
                    startDrag(e, l);
                };
                canvas.appendChild(wrapper);
                return;
            }

            el.onmousedown = (e) => { 
                e.stopPropagation();
                if (l.locked) return; // Locked layers cannot be selected via canvas click
                activeLayer = l; 
                // Highlight Actions sidebar button when a sprite with packData is selected
                const actBtn = document.getElementById('sb-actions-btn');
                if (actBtn) actBtn.classList.toggle('active', !!l.packData);
                document.getElementById('edit-action-btn').style.display = 'none';
                document.getElementById('onion-skin-control').style.display = 'flex';
                render();
                // Show floating toolbar for text layers, hide for others
                if (['text','bubble','thinking','subtitle'].includes(l.type)) {
                    setTimeout(() => showFloatToolbar(l), 20);
                } else {
                    hideFloatToolbar();
                }
                startDrag(e, l); 
            };
            canvas.appendChild(el);
        });
        document.getElementById('frame-label').innerText = `${currentIdx + 1} / ${frames.length}`;
        document.getElementById('global-frame-indicator').innerText = `FRAME ${currentIdx + 1}`;
        renderDrawer();
    }

    function copyCurrentFrame() {
        frameClipboard = JSON.stringify(frames[currentIdx]);
        alert("Frame data copied!");
    }

    function pasteFrame() {
        if(!frameClipboard) return alert("Clipboard is empty!");
        saveState();
        frames[currentIdx] = JSON.parse(frameClipboard);
        render();
    }

    function duplicateFrame() { 
        saveState(); 
        const copy = JSON.parse(JSON.stringify(frames[currentIdx])); 
        frames.splice(currentIdx + 1, 0, copy); 
        currentIdx++; 
        render(); 
    }

    function addFrame() { saveState(); frames.push({ layers: [], background: '#ffffff' }); currentIdx = frames.length - 1; render(); }
    function nextFrame() { if (currentIdx < frames.length - 1) { currentIdx++; render(); } else addFrame(); }
    function prevFrame() { if (currentIdx > 0) { currentIdx--; render(); } }
    function goToFrame(idx) { currentIdx = idx; render(); }
    function deleteFrame() { if (frames.length > 1) { saveState(); frames.splice(currentIdx, 1); if (currentIdx >= frames.length) currentIdx = frames.length - 1; render(); } }

    function triggerImport(type) { currentImportType = type; document.getElementById('img-input').click(); toggleMenu('plus-menu'); }
    
    document.getElementById('img-input').onchange = (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            if (currentImportType === 'bg') {
                // Show Crop / Fixed Import choice for background uploads
                showBgImportChoice(ev.target.result);
            } else {
                document.getElementById('crop-modal').style.display = 'flex';
                const target = document.getElementById('crop-target');
                target.src = ev.target.result;
                if(cropper) cropper.destroy();
                cropper = new Cropper(target, { aspectRatio: NaN, viewMode: 1 });
            }
        };
        reader.readAsDataURL(file);
        e.target.value = '';
    };

    document.getElementById('apply-crop-btn').onclick = () => {
        const b64 = cropper.getCroppedCanvas().toDataURL('image/png');
        if(currentImportType === 'cover') {
            finalCoverBase64 = b64;
            const img = document.getElementById('final-cover-img');
            img.src = b64; img.style.display = 'block';
            document.getElementById('cover-label').style.display = 'none';
        } else {
            saveState();
            if(currentImportType === 'bg') frames[currentIdx].background = b64;
            else frames[currentIdx].layers.push({ type: 'img', src: b64, w: 200, x: 50, y: 50, rotation: 0, flipped: false, id: Date.now() });
        }
        closeCrop(); render();
    };

    function toggleMenu(id) {
        const m = document.getElementById(id);
        const isOpen = m.style.display === 'flex';
        document.querySelectorAll('.menu-popup').forEach(p => p.style.display = 'none');
        m.style.display = isOpen ? 'none' : 'flex';
        if(id === 'layer-menu') renderLayerList();
    }

    function renderLayerList() {
        const container = document.getElementById('layer-list-container'); container.innerHTML = "";
        [...frames[currentIdx].layers].reverse().forEach((l) => {
            const btn = document.createElement('button'); btn.className = 'menu-item'; btn.style.fontSize = '11px';
            const label = l.type.toUpperCase() + (l.content ? `: ${l.content.substring(0,10)}` : (l.nameTag ? ` [${l.nameTag}]` : ''));
            btn.innerText = label;
            const isActive  = activeLayer?.id === l.id;
            const isInSel   = selectedLayers.some(s => s.id === l.id);
            if (isActive)  btn.style.borderColor = 'var(--accent)';
            if (isInSel)   btn.classList.add('layer-item-sel');
            btn.onclick = (e) => {
                if (e.shiftKey || e.ctrlKey || e.metaKey) {
                    // Multi-select toggle
                    const idx = selectedLayers.findIndex(s => s.id === l.id);
                    if (idx === -1) selectedLayers.push(l); else selectedLayers.splice(idx, 1);
                } else {
                    selectedLayers = [l];
                    activeLayer = l;
                }
                render();
                renderLayerList();
                updateFxHint();
            };
            container.appendChild(btn);
        });
    }

    function toggleTransform() {
        // If no layer selected, open bg edit panel directly
        if (!activeLayer) { openBgPanel(); return; }
        const ui = document.getElementById('transform-ui');
        const textUi = document.getElementById('text-settings');
        const onionUi = document.getElementById('onion-skin-control');
        const scaleGroup = document.getElementById('scale-slider-group');
        const blurRow = document.getElementById('sprite-blur-row');
        const nametagRow = document.getElementById('sprite-nametag-row');

        const isOpen = ui.style.display === 'flex';
        ui.style.display = isOpen ? 'none' : 'flex';
        // onion skin stays visible as long as a layer is selected

        if(!isOpen) {
            document.getElementById('size-slider').value = activeLayer.w;
            document.getElementById('rotate-slider').value = activeLayer.rotation || 0;
            // Sync number inputs
            document.getElementById('size-num').value = activeLayer.w;
            document.getElementById('rotate-num').value = activeLayer.rotation || 0;
            // Sync X/Y
            document.getElementById('pos-x-input').value = Math.round(activeLayer.x) || 0;
            document.getElementById('pos-y-input').value = Math.round(activeLayer.y) || 0;
            
            const isTextType = (activeLayer.type === 'bubble' || activeLayer.type === 'thinking' || activeLayer.type === 'text');
            const isImgType  = activeLayer.type === 'img';
            textUi.style.display    = isTextType ? 'flex' : 'none';
            scaleGroup.style.display = isTextType ? 'none' : 'flex';

            // Show blur + nametag panels only for image layers
            blurRow.style.display    = isImgType ? 'flex' : 'none';
            nametagRow.style.display = isImgType ? 'flex' : 'none';
            // Always show Edit Background button in EDIT panel
            document.getElementById('edit-bg-btn').style.display = 'block';

            if (isImgType) {
                // Sync blur UI
                const bType = activeLayer.blurType || 'none';
                const bAmt  = activeLayer.blurAmount || 4;
                ['none','soft','pixel'].forEach(t => {
                    document.getElementById('blur-' + t + '-btn').classList.toggle('active', t === bType);
                });
                document.getElementById('blur-amount').value       = bAmt;
                document.getElementById('blur-amount-val').innerText = bAmt + 'px';
                document.getElementById('blur-amount-row').style.display = bType === 'none' ? 'none' : 'flex';
                // Sync nametag
                document.getElementById('sprite-nametag-input').value = activeLayer.nameTag || '';
            }

            if(isTextType) {
                document.getElementById('font-family-select').value = activeLayer.fontFamily || "'Inter', sans-serif";
                document.getElementById('font-size-slider').value = activeLayer.fontSize || 28;
                document.getElementById('font-size-num').value = activeLayer.fontSize || 28;
                document.getElementById('text-content-input').value = activeLayer.content || "";

                const isBubble = activeLayer.type === 'bubble' || activeLayer.type === 'thinking';
                const bsRow = document.getElementById('bubble-style-change-row');
                bsRow.style.display = isBubble ? 'flex' : 'none';
                if (isBubble) {
                    document.getElementById('bubble-bg-color').value = activeLayer.bubbleBg || '#ffffff';
                    document.getElementById('bubble-border-color').value = activeLayer.bubbleBorderColor || '#000000';
                    populateBubbleMiniGrid();
                }
            }
        }
    }

    function saveState() {
        history.push(JSON.stringify(frames));
        if (history.length > 30) history.shift();
        redoStack = []; hasUnsavedChanges = true;
    }

    function undo() { if (history.length > 0) { redoStack.push(JSON.stringify(frames)); frames = JSON.parse(history.pop()); render(); } }
    function redo() { if (redoStack.length > 0) { history.push(JSON.stringify(frames)); frames = JSON.parse(redoStack.pop()); render(); } }

    function saveOffline(silent = false) {
        let drafts = JSON.parse(localStorage.getItem('comic_drafts') || '[]');
        if (activeDraftId) {
            const idx = drafts.findIndex(d => d.id == activeDraftId);
            if (idx !== -1) {
                drafts[idx].data = frames;
                drafts[idx].ratio = canvasRatio || { w: 1, h: 1 };
                drafts[idx].lastModified = new Date().toLocaleString();
            } else {
                // Draft was deleted elsewhere, re-add it
                drafts.push({ id: activeDraftId, title: 'Untitled', data: frames, ratio: canvasRatio || { w: 1, h: 1 }, lastModified: new Date().toLocaleString() });
            }
        } else {
            // First save ‚Äî ask for name unless silent
            let title = silent ? 'Untitled' : (prompt("Draft Name:", "New Comic") || "Untitled");
            const newDraft = { id: Date.now(), title, data: frames, ratio: canvasRatio || { w: 1, h: 1 }, lastModified: new Date().toLocaleString() };
            drafts.push(newDraft);
            activeDraftId = newDraft.id;
            localStorage.setItem('active_draft_id', activeDraftId);
        }
        localStorage.setItem('comic_drafts', JSON.stringify(drafts));
        hasUnsavedChanges = false;
        if (!silent) {
            const btn = document.querySelector('.tb-btn[onclick*="saveOffline"]');
            if (btn) { const orig = btn.innerText; btn.innerText = '‚úì Saved!'; setTimeout(() => btn.innerText = orig, 1500); }
        }
    }

    function goToDrafts() {
        saveOffline(true); // silent auto-save before leaving
        location.href = 'offlines.html';
    }

    // Auto-save every 30 seconds if there are unsaved changes
    setInterval(() => {
        if (hasUnsavedChanges && activeDraftId) saveOffline(true);
    }, 30000);

    // Save before page unload
    window.addEventListener('beforeunload', () => {
        if (frames && frames.length) saveOffline(true);
    });

    function openPublishModal() { document.getElementById('publish-modal').style.display = 'flex'; }

    async function finalPublish() {
        const title = document.getElementById('pub-title').value;
        const desc = document.getElementById('pub-desc').value;
        const tagsRaw = document.getElementById('pub-tags').value;
        const tags = tagsRaw.split(',').map(t => t.trim()).filter(t => t !== "");
        if(!title || !finalCoverBase64) return alert("Title and Cover required!");
        const btn = document.getElementById('publish-btn');
        btn.innerText = editingComicId ? "Updating..." : "Publishing...";
        btn.disabled = true;
        const profile = JSON.parse(localStorage.getItem('user_profile') || '{"name":"Creator","handle":"user"}');
        const swipeDir = localStorage.getItem('cc-swipe-dir') || 'horizontal';
        const payload = {
            title, description: desc, tags, cover: finalCoverBase64,
            data: frames, swipe_dir: swipeDir,
            canvas_ratio: canvasRatio
        };
        let error;
        if (editingComicId) {
            // Update existing comic
            ({ error } = await _supabase.from('comics').update(payload).eq('id', editingComicId));
        } else {
            // New publish
            ({ error } = await _supabase.from('comics').insert([{
                ...payload, owner_name: profile.name, owner_handle: profile.handle, stars: 0, starred_by: []
            }]));
        }
        if (error) {
            alert(error.message);
            btn.innerText = editingComicId ? "UPDATE" : "POST NOW";
            btn.disabled = false;
        } else {
            hasUnsavedChanges = false;
            location.href = 'discover.html';
        }
    }

    function closeLibrary() { document.getElementById('library-modal').style.display = 'none'; }
    function closeActionModal() { document.getElementById('action-modal').style.display = 'none'; }
    function closePublish() { document.getElementById('publish-modal').style.display = 'none'; }
    function closeCrop() { document.getElementById('crop-modal').style.display = 'none'; if(cropper) { cropper.destroy(); cropper = null; } }

    // Bg Import Choice Modal
    let pendingBgImageSrc = null;

    function showBgImportChoice(src) {
        pendingBgImageSrc = src;
        document.getElementById('bg-choice-preview').src = src;
        document.getElementById('bg-import-choice-modal').style.display = 'flex';
    }

    function closeBgChoiceModal() {
        document.getElementById('bg-import-choice-modal').style.display = 'none';
        pendingBgImageSrc = null;
    }

    function bgChoiceCrop() {
        document.getElementById('bg-import-choice-modal').style.display = 'none';
        const target = document.getElementById('crop-target');
        const initCropper = () => {
            if (cropper) cropper.destroy();
            const ratio = canvasRatio ? (canvasRatio.w / canvasRatio.h) : 1;
            cropper = new Cropper(target, { aspectRatio: ratio, viewMode: 1 });
        };
        document.getElementById('crop-modal').style.display = 'flex';
        target.onload = initCropper;
        if (target.src === pendingBgImageSrc && target.complete) {
            initCropper();
        } else {
            target.src = pendingBgImageSrc;
        }
    }

    function bgChoiceFixed() {
        document.getElementById('bg-import-choice-modal').style.display = 'none';
        const src = pendingBgImageSrc;
        pendingBgImageSrc = null;
        const img = new Image();
        img.onload = () => {
            const targetRatio = canvasRatio ? (canvasRatio.w / canvasRatio.h) : 1;
            const imgRatio = img.width / img.height;
            let sx, sy, sw, sh;
            if (imgRatio > targetRatio) {
                sh = img.height; sw = img.height * targetRatio;
                sy = 0; sx = (img.width - sw) / 2;
            } else {
                sw = img.width; sh = img.width / targetRatio;
                sx = 0; sy = (img.height - sh) / 2;
            }
            const offscreen = document.createElement('canvas');
            offscreen.width  = 1200;
            offscreen.height = Math.round(1200 / targetRatio);
            const ctx = offscreen.getContext('2d');
            ctx.drawImage(img, sx, sy, sw, sh, 0, 0, offscreen.width, offscreen.height);
            const b64 = offscreen.toDataURL('image/jpeg', 0.9);
            saveState();
            frames[currentIdx].background = b64;
            render();
        };
        img.crossOrigin = 'anonymous';
        img.src = src;
    }
    function toggleDrawer() { document.getElementById('frame-drawer').classList.toggle('open'); }

    function toggleOnionSkin() {
        const cb  = document.getElementById('onion-toggle');
        const img = document.getElementById('onion-icon-img');
        cb.checked = !cb.checked;
        if (cb.checked) {
            img.style.opacity = '1';
            img.style.filter  = 'drop-shadow(0 0 6px #00d2ff) drop-shadow(0 0 12px rgba(0,210,255,0.6))';
        } else {
            img.style.opacity = '0.4';
            img.style.filter  = 'none';
        }
        render();
    }
    function handleExit() {
        // Save silently in background then navigate immediately
        try { saveOffline(true); } catch(e) {}
        location.href = 'index.html';
    }
    function flipHorizontal() { if(activeLayer) { saveState(); activeLayer.flipped = !activeLayer.flipped; render(); } }
    function createActionOption(src, name) { const div = document.createElement('div'); div.className = 'action-option'; div.innerHTML = `<img src="${src}"><span>${name}</span>`; return div; }
    
    // ‚îÄ‚îÄ Bubble Picker ‚îÄ‚îÄ
    const BUBBLE_STYLES = [
        { id: 'round',    label: 'üí¨ Classic',   types: ['speech'],   svg: `<svg viewBox="0 0 100 90" xmlns="http://www.w3.org/2000/svg"><ellipse cx="50" cy="40" rx="42" ry="32" fill="white" stroke="black" stroke-width="4"/><polygon points="22,68 36,70 28,84" fill="black"/><polygon points="24,68 36,68 30,80" fill="white"/></svg>` },
        { id: 'chat',     label: 'üí¨ Modern',    types: ['speech'],   svg: `<svg viewBox="0 0 100 90" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="10" width="84" height="58" rx="16" fill="white" stroke="black" stroke-width="4"/><polygon points="68,68 82,68 82,82" fill="black"/><polygon points="70,66 82,66 82,80" fill="white"/></svg>` },
        { id: 'rect',     label: '‚ñ≠ Sharp',      types: ['speech'],   svg: `<svg viewBox="0 0 100 90" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="88" height="58" rx="3" fill="white" stroke="black" stroke-width="4"/><polygon points="38,66 62,66 50,82" fill="black"/><polygon points="40,64 60,64 50,78" fill="white"/></svg>` },
        { id: 'whisper',  label: 'ü§´ Whisper',   types: ['speech'],   svg: `<svg viewBox="0 0 100 90" xmlns="http://www.w3.org/2000/svg"><ellipse cx="50" cy="38" rx="42" ry="30" fill="rgba(255,255,255,0.9)" stroke="black" stroke-width="3.5" stroke-dasharray="6,4"/><polygon points="20,65 34,66 26,80" fill="black"/><polygon points="22,64 34,64 28,77" fill="rgba(255,255,255,0.9)"/></svg>` },
        { id: 'shout',    label: 'üì¢ Shout',     types: ['speech'],   svg: `<svg viewBox="0 0 100 90" xmlns="http://www.w3.org/2000/svg"><polygon points="50,4 62,12 76,6 80,20 94,22 88,36 100,46 86,52 92,66 76,66 74,80 60,74 50,86 40,74 26,80 24,66 8,66 14,52 0,46 12,36 6,22 20,20 24,6 38,12" fill="#ffeb3b" stroke="black" stroke-width="3"/></svg>` },
        { id: 'spiky',    label: 'üí• Burst',     types: ['speech'],   svg: `<svg viewBox="0 0 100 90" xmlns="http://www.w3.org/2000/svg"><polygon points="50,2 58,16 72,8 73,24 87,18 84,34 99,33 90,46 100,56 84,58 90,72 74,70 73,85 59,77 50,90 41,77 27,85 26,70 10,72 16,58 0,56 10,46 1,33 16,34 13,18 27,24 28,8 42,16" fill="white" stroke="black" stroke-width="3"/></svg>` },
        { id: 'electric', label: '‚ö° Electric',  types: ['speech'],   svg: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><polygon points="8,4 92,4 100,12 100,88 92,96 60,96 54,108 46,96 8,96 0,88 0,12" fill="white" stroke="black" stroke-width="4"/></svg>` },
        { id: 'narrator', label: 'üìã Narrator',  types: ['speech'],   svg: `<svg viewBox="0 0 100 80" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="88" height="64" rx="4" fill="#fffde7" stroke="black" stroke-width="4"/><rect x="6" y="8" width="8" height="64" rx="0" fill="black"/></svg>` },
        { id: 'cloud',    label: '‚òÅÔ∏è Cloud',     types: ['thinking'], svg: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><ellipse cx="50" cy="46" rx="38" ry="28" fill="white" stroke="black" stroke-width="4"/><ellipse cx="30" cy="30" rx="18" ry="14" fill="white" stroke="black" stroke-width="4"/><ellipse cx="64" cy="28" rx="16" ry="12" fill="white" stroke="black" stroke-width="4"/><circle cx="30" cy="80" r="6" fill="white" stroke="black" stroke-width="3"/><circle cx="20" cy="90" r="4" fill="white" stroke="black" stroke-width="2.5"/><circle cx="12" cy="97" r="2.5" fill="white" stroke="black" stroke-width="2"/></svg>` },
    ];

    let _bubblePickerMode = 'speech';
    let _bubblePickerSelected = 'round';

    function populateBubbleMiniGrid() {
        if (!activeLayer) return;
        const miniGrid = document.getElementById('bubble-style-mini-grid');
        if (!miniGrid) return;
        miniGrid.innerHTML = '';
        BUBBLE_STYLES.forEach(s => {
            const card = document.createElement('div');
            const isActive = (activeLayer.bubbleStyle || (activeLayer.type==='thinking'?'cloud':'round')) === s.id;
            card.style.cssText = `background:#111;border:2px solid ${isActive?'var(--accent)':'#333'};border-radius:10px;padding:6px 4px;cursor:pointer;text-align:center;transition:0.15s;`;
            card.innerHTML = `<div style="width:100%;aspect-ratio:1;display:flex;align-items:center;justify-content:center;">${s.svg}</div><div style="font-size:9px;color:#aaa;font-weight:800;margin-top:3px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${s.label}</div>`;
            card.onclick = () => { activeLayer.bubbleStyle = s.id; render(); populateBubbleMiniGrid(); };
            miniGrid.appendChild(card);
        });
    }

    function openBubblePicker(mode) {
        _bubblePickerMode = mode;
        _bubblePickerSelected = (mode === 'thinking') ? 'cloud' : 'round';
        document.getElementById('bubble-picker-title').textContent = mode === 'thinking' ? 'üí≠ Choose Thinking Style' : 'üí¨ Choose Speech Style';
        document.getElementById('bubble-picker-text').value = '';

        const grid = document.getElementById('bubble-style-grid');
        grid.innerHTML = '';
        BUBBLE_STYLES.forEach(s => {
            const card = document.createElement('div');
            card.style.cssText = `background:#111;border:2px solid ${_bubblePickerSelected===s.id?'var(--accent)':'#333'};border-radius:14px;padding:10px 6px;cursor:pointer;text-align:center;transition:0.15s;`;
            card.innerHTML = `<div style="width:100%;aspect-ratio:1;display:flex;align-items:center;justify-content:center;">${s.svg}</div><div style="font-size:10px;color:#aaa;font-weight:800;margin-top:5px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${s.label}</div>`;
            card.onclick = () => {
                _bubblePickerSelected = s.id;
                openBubblePicker(mode); // re-render to update selection
                document.getElementById('bubble-picker-modal').style.display = 'flex'; // keep open
            };
            grid.appendChild(card);
        });

        const modal = document.getElementById('bubble-picker-modal');
        modal.style.display = 'flex';
        setTimeout(() => document.getElementById('bubble-picker-text').focus(), 100);
    }

    function closeBubblePicker() {
        document.getElementById('bubble-picker-modal').style.display = 'none';
    }

    function confirmBubblePicker() {
        const txt = document.getElementById('bubble-picker-text').value.trim();
        if (!txt) { document.getElementById('bubble-picker-text').focus(); return; }
        closeBubblePicker();
        saveState();
        const type = _bubblePickerMode === 'thinking' ? 'thinking' : 'bubble';
        const nl = {
            type, content: txt,
            bubbleStyle: _bubblePickerSelected,
            x: Math.round((canvas.getBoundingClientRect().width - 180) / 2),
            y: Math.round(canvas.getBoundingClientRect().height / 2 - 60),
            w: 180, fontSize: 22, fontFamily: "'Inter', sans-serif", id: Date.now()
        };
        frames[currentIdx].layers.push(nl);
        activeLayer = nl;
        render();
    }

    // Enter key on bubble picker text
    document.addEventListener('DOMContentLoaded', () => {
        const inp = document.getElementById('bubble-picker-text');
        if (inp) inp.addEventListener('keydown', e => { if (e.key === 'Enter') confirmBubblePicker(); });
    });

    function addText(mode) { 
        if (mode === 'standard') { openBubblePicker('speech'); return; }
        if (mode === 'thinking') { openBubblePicker('thinking'); return; }
        const txt = prompt("Enter text:"); 
        if(txt) { 
            saveState(); 
            const nl = { 
                type: 'text', 
                content: txt, x: Math.round((canvas.getBoundingClientRect().width - 180) / 2), y: Math.round(canvas.getBoundingClientRect().height / 2 - 60), w: 180, 
                fontSize: 28, fontFamily: "'Inter', sans-serif", id: Date.now() 
            };
            frames[currentIdx].layers.push(nl); 
            activeLayer = nl; render(); 
        } 
    }
    
    
    // ‚îÄ‚îÄ Copy / Paste / Center layer ‚îÄ‚îÄ
    let layerClipboard = null;
    let bgClipboard = null;

    function copyLayer() {
        if (!activeLayer) return alert("Select a layer first!");
        layerClipboard = JSON.parse(JSON.stringify(activeLayer));
        alert("Layer copied!");
    }

    function pasteLayer() {
        if (!layerClipboard) return alert("Nothing copied yet!");
        saveState();
        const pasted = JSON.parse(JSON.stringify(layerClipboard));
        pasted.id = Date.now();
        const canvasRect = canvas.getBoundingClientRect();
        pasted.x = Math.min((pasted.x || 0) + 20, canvasRect.width  - (pasted.w || 100));
        pasted.y = Math.min((pasted.y || 0) + 20, canvasRect.height - (pasted.w || 100));
        frames[currentIdx].layers.push(pasted);
        activeLayer = pasted;
        render();
    }

    // ‚îÄ‚îÄ Background copy/paste ‚îÄ‚îÄ
    function copyBackground() {
        const f = frames[currentIdx];
        bgClipboard = { background: f.background, bgSettings: f.bgSettings ? JSON.parse(JSON.stringify(f.bgSettings)) : null };
        showKbFlash('üì∑ Background copied!');
    }

    function pasteBackground() {
        if (!bgClipboard) return showKbFlash('Nothing in background clipboard');
        saveState();
        frames[currentIdx].background = bgClipboard.background;
        if (bgClipboard.bgSettings) frames[currentIdx].bgSettings = JSON.parse(JSON.stringify(bgClipboard.bgSettings));
        render();
        showKbFlash('üì∑ Background pasted!');
    }

    // ‚îÄ‚îÄ Keyboard shortcut flash message ‚îÄ‚îÄ
    function showKbFlash(msg) {
        let el = document.getElementById('kb-flash');
        if (!el) {
            el = document.createElement('div');
            el.id = 'kb-flash';
            el.style.cssText = 'position:fixed;bottom:110px;left:50%;transform:translateX(-50%);background:rgba(30,30,30,0.95);color:#fff;padding:8px 18px;border-radius:10px;font-weight:800;font-size:12px;z-index:9999;pointer-events:none;border:1px solid #333;letter-spacing:0.5px;transition:opacity 0.3s;';
            document.body.appendChild(el);
        }
        el.innerText = msg;
        el.style.opacity = '1';
        clearTimeout(el._t);
        el._t = setTimeout(() => el.style.opacity = '0', 1800);
    }

    function centerLayer() {
        if (!activeLayer) return;
        saveState();
        const canvasRect = canvas.getBoundingClientRect();
        const layerW = activeLayer.w || 100;
        const layerH = activeLayer.h || (activeLayer.fontSize ? activeLayer.fontSize * 2 : layerW);
        activeLayer.x = Math.round((canvasRect.width  - layerW) / 2);
        activeLayer.y = Math.round((canvasRect.height - layerH) / 2);
        render();
    }

    function alignLayer(hAlign, vAlign) {
        if (!activeLayer) return;
        saveState();
        const canvasRect = canvas.getBoundingClientRect();
        const layerW = activeLayer.w || 100;
        const layerH = activeLayer.h || (activeLayer.fontSize ? activeLayer.fontSize * 2 : layerW);
        if (hAlign === 'left')   activeLayer.x = 0;
        if (hAlign === 'center') activeLayer.x = Math.round((canvasRect.width - layerW) / 2);
        if (hAlign === 'right')  activeLayer.x = Math.round(canvasRect.width - layerW);
        if (vAlign === 'top')    activeLayer.y = 0;
        if (vAlign === 'middle') activeLayer.y = Math.round((canvasRect.height - layerH) / 2);
        if (vAlign === 'bottom') activeLayer.y = Math.round(canvasRect.height - layerH);
        render();
    }

    function deleteLayer() { 
        if(activeLayer) { 
            saveState(); 
            frames[currentIdx].layers = frames[currentIdx].layers.filter(l => l.id !== activeLayer.id); 
            activeLayer = null; 
            document.getElementById('transform-ui').style.display = 'none';
            document.getElementById('edit-action-btn').style.display = 'none';
            document.getElementById('onion-skin-control').style.display = 'none';
            render(); 
        } 
    }
    
    function renderDrawer() {
        const container = document.getElementById('thumb-container'); container.innerHTML = "";
        frames.forEach((f, i) => {
            const isUrl      = f.background.startsWith('http') || f.background.startsWith('data:image');
            const isGradient = f.background.startsWith('linear-gradient') || f.background.startsWith('radial-gradient');
            const bg = isUrl      ? `background-image:url(${f.background})`
                     : isGradient ? `background-image:${f.background}`
                     :              `background-color:${f.background}`;
            container.innerHTML += `<div class="frame-thumb ${i === currentIdx ? 'active' : ''}" style="${bg}" onclick="goToFrame(${i})">#${i+1}</div>`;
        });
    }

    document.getElementById('rotate-slider').oninput = function() { 
        if(activeLayer) { activeLayer.rotation = this.value; render(); }
        const n = document.getElementById('rotate-num'); if(n) n.value = this.value;
    };
    document.getElementById('size-slider').oninput = function() { 
        if(activeLayer) { activeLayer.w = this.value; render(); }
        const n = document.getElementById('size-num'); if(n) n.value = this.value;
    };
    // Number input ‚Üí slider sync
    document.getElementById('size-num').oninput = function() {
        const v = Math.min(1000, Math.max(20, parseInt(this.value) || 20));
        document.getElementById('size-slider').value = v;
        if(activeLayer) { activeLayer.w = v; render(); }
    };
    document.getElementById('rotate-num').oninput = function() {
        const v = Math.min(360, Math.max(0, parseInt(this.value) || 0));
        document.getElementById('rotate-slider').value = v;
        if(activeLayer) { activeLayer.rotation = v; render(); }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CANVAS RATIO SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const BASE_SIZE = 900;
    let canvasRatio = null;

    function setRatio(w, h) {
        canvasRatio = { w, h };
        localStorage.setItem('cc-active-ratio', JSON.stringify({ w, h }));
        const cw = w >= h ? BASE_SIZE : Math.round(BASE_SIZE * w / h);
        const ch = h >= w ? BASE_SIZE : Math.round(BASE_SIZE * h / w);
        canvas.style.width  = cw + 'px';
        canvas.style.height = ch + 'px';
        onionCanvas.setAttribute('width',  cw);
        onionCanvas.setAttribute('height', ch);
        onionCanvas.style.width  = cw + 'px';
        onionCanvas.style.height = ch + 'px';
        render();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FLOATING TEXT TOOLBAR
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let ftbDragging = false;

    // ‚îÄ‚îÄ iOS Float Toolbar ‚îÄ‚îÄ
    function showFloatToolbar(layer) {
        if (!layer) return;
        const pill   = document.getElementById('ftb-pill');
        const canvas = document.getElementById('comic-frame');
        const rect   = canvas.getBoundingClientRect();
        const scaleX = rect.width  / canvas.offsetWidth;
        const scaleY = rect.height / canvas.offsetHeight;

        const layerCenterX = rect.left + (layer.x + layer.w / 2) * scaleX;
        const layerTopY    = rect.top  + layer.y * scaleY;

        // Pill sits 12px above the layer top ‚Äî panel grows upward via CSS, pill never moves
        const PILL_H = 44;
        let pillTop  = layerTopY - 12 - PILL_H;
        if (pillTop < 10) pillTop = layerTopY + (layer.fontSize || 28) + 20; // fallback below

        let left = layerCenterX;
        left = Math.max(140, Math.min(left, window.innerWidth - 140));

        pill.style.left = left + 'px';
        pill.style.top  = pillTop + 'px';
        pill.classList.add('visible');
        syncPanelToLayer(layer);
    }

    function hideFloatToolbar() {
        const pill = document.getElementById('ftb-pill');
        pill.classList.remove('visible');
        closeFtbPanel();
    }

    function closeFtbPanel() {
        document.getElementById('ftb-panel').classList.remove('open');
        document.getElementById('ftb-caret').style.display = 'none';
    }

    function ftbTogglePanel() {
        const panel  = document.getElementById('ftb-panel');
        const caret  = document.getElementById('ftb-caret');
        const isOpen = panel.classList.contains('open');
        panel.classList.toggle('open', !isOpen);
        caret.style.display = isOpen ? 'none' : 'block';
    }

    function syncPanelToLayer(layer) {
        if (!layer) return;
        // Color dot ‚Äî for subtitle, color wheel controls name bar color
        const color = layer.type === 'subtitle'
            ? (layer.nameColor || '#ff9500')
            : (layer.color || '#000000');
        document.getElementById('ftb-dot').style.background       = color;
        document.getElementById('ftb-color-btn').style.background = color;
        document.getElementById('ftb-color-input').value          = color.startsWith('#') ? color : '#ff9500';
        // Bold/italic/underline/strike
        document.getElementById('ftb-bold').classList.toggle('active',      !!layer.bold);
        document.getElementById('ftb-italic').classList.toggle('active',    !!layer.italic);
        document.getElementById('ftb-underline').classList.toggle('active', !!layer.underline);
        document.getElementById('ftb-strike').classList.toggle('active',    !!layer.strikethrough);
        // Size
        document.getElementById('ftb-size-display').innerText = layer.fontSize || 28;
        // Font
        const fontSel = document.getElementById('ftb-font-select');
        if (layer.fontFamily) fontSel.value = layer.fontFamily;
        // Align
        const align = layer.align || 'left';
        ['left','center','right'].forEach(a => {
            document.getElementById('ftb-al-' + a).classList.toggle('active', a === align);
        });
    }

    function ftbColor(hex) {
        if (!activeLayer) return;
        if (activeLayer.type === 'subtitle') {
            activeLayer.nameColor = hex; // color wheel changes name bar color
        } else {
            activeLayer.color = hex;
        }
        document.getElementById('ftb-dot').style.background       = hex;
        document.getElementById('ftb-color-btn').style.background = hex;
        // Also update the bubble bg override if it's a bubble
        // (text color is stored in l.color and applied in render)
        render();
        // Re-sync ftb-color-input value in case browser didn't update it
        const inp = document.getElementById('ftb-color-input');
        if (inp && hex.startsWith('#')) inp.value = hex;
    }

    function ftbSize(delta) {
        if (!activeLayer) return;
        activeLayer.fontSize = Math.min(Math.max((activeLayer.fontSize || 28) + delta, 8), 160);
        document.getElementById('ftb-size-display').innerText = activeLayer.fontSize;
        render();
        showFloatToolbar(activeLayer);
    }

    function ftbFont(val) {
        if (!activeLayer) return;
        activeLayer.fontFamily = val;
        render();
    }

    function ftbToggle(prop) {
        if (!activeLayer) return;
        if (prop === 'bold')          activeLayer.bold          = !activeLayer.bold;
        else if (prop === 'italic')   activeLayer.italic        = !activeLayer.italic;
        else if (prop === 'underline') activeLayer.underline    = !activeLayer.underline;
        else if (prop === 'strikethrough') activeLayer.strikethrough = !activeLayer.strikethrough;
        syncPanelToLayer(activeLayer);
        render();
    }

    function ftbAlign(align) {
        if (!activeLayer) return;
        activeLayer.align = align;
        ['left','center','right'].forEach(a => {
            document.getElementById('ftb-al-' + a).classList.toggle('active', a === align);
        });
        render();
    }

    function ftbDuplicate() {
        if (!activeLayer) return;
        const copy = JSON.parse(JSON.stringify(activeLayer));
        copy.x += 15; copy.y += 15;
        frames[currentIdx].layers.push(copy);
        activeLayer = copy;
        render();
        showFloatToolbar(copy);
    }

    function ftbDelete() {
        if (!activeLayer) return;
        if (!confirm('Delete this layer?')) return;
        frames[currentIdx].layers = frames[currentIdx].layers.filter(l => l !== activeLayer);
        activeLayer = null;
        hideFloatToolbar();
        render();
    }

    function ftbMore() {
        if (!activeLayer) return;
        if (activeLayer.type === 'subtitle') {
            const charName = prompt('Character name:', activeLayer.characterName || 'CHARACTER');
            if (charName !== null) activeLayer.characterName = charName.toUpperCase();
            const dialogue = prompt('Dialogue:', activeLayer.content || '');
            if (dialogue !== null) activeLayer.content = dialogue;
        } else {
            const newText = prompt('Edit text:', activeLayer.content || '');
            if (newText !== null) activeLayer.content = newText;
        }
        render();
        showFloatToolbar(activeLayer);
    }


    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // EXPORT SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function openExportModal()  { document.getElementById('export-modal').style.display = 'flex'; }
    function closeExportModal() { document.getElementById('export-modal').style.display = 'none'; }

    function switchExportTab(tab) {
        document.querySelectorAll('.export-tab').forEach((t, i) => t.classList.toggle('active', (i === 0) === (tab === 'gif')));
        document.getElementById('export-gif').classList.toggle('active', tab === 'gif');
        document.getElementById('export-strip').classList.toggle('active', tab === 'strip');
    }

    // FIX 1: frameToCanvas now respects canvasRatio so exported frames are not distorted
    async function frameToCanvas(frameIdx, size) {
        const f = frames[frameIdx];
        const offscreen = document.createElement('canvas');

        // Calculate correct dimensions from canvas ratio ‚Äî never assume square
        const ratio = canvasRatio ? (canvasRatio.w / canvasRatio.h) : 1;
        const offW = ratio >= 1 ? size : Math.round(size * ratio);
        const offH = ratio <= 1 ? size : Math.round(size / ratio);
        offscreen.width  = offW;
        offscreen.height = offH;

        const ctx = offscreen.getContext('2d');

        // Background ‚Äî handle solid colors, gradients, and image URLs
        const bg = f.background || '#ffffff';
        const isBgImage    = bg.startsWith('http') || bg.startsWith('data:image');
        const isBgGradient = bg.startsWith('linear-gradient') || bg.startsWith('radial-gradient');

        if (isBgImage) {
            // Draw background image, respecting bgSettings scale/position
            await new Promise(res => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const s      = f.bgSettings || {};
                    const scale  = (s.scale  ?? 100) / 100;
                    const xOff   = ((s.x ?? 0) / 100) * offW;
                    const yOff   = ((s.y ?? 0) / 100) * offH;
                    const rotate = ((s.rotate ?? 0) * Math.PI) / 180;
                    const drawW  = offW * scale;
                    const drawH  = offH * scale;
                    ctx.save();
                    ctx.translate(offW / 2 + xOff, offH / 2 + yOff);
                    ctx.rotate(rotate);
                    ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
                    ctx.restore();
                    res();
                };
                img.onerror = () => { ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, offW, offH); res(); };
                img.src = bg;
            });
        } else if (isBgGradient) {
            // Parse and draw CSS gradient onto canvas
            // We render it by drawing the gradient string into a temporary offscreen via a hidden div approach,
            // but the simplest reliable method is to create a gradient from the CSS string approximation.
            // For linear-gradient we extract angle + color stops.
            const gradCanvas = document.createElement('canvas');
            gradCanvas.width = offW; gradCanvas.height = offH;
            const gCtx = gradCanvas.getContext('2d');

            // Use a helper: draw bg string via SVG foreignObject ‚Üí Image, which supports CSS gradients
            const svgStr = `<svg xmlns="http://www.w3.org/2000/svg" width="${offW}" height="${offH}">
                <foreignObject width="100%" height="100%">
                    <div xmlns="http://www.w3.org/1999/xhtml"
                         style="width:${offW}px;height:${offH}px;background:${bg.replace(/"/g,"'")};">
                    </div>
                </foreignObject>
            </svg>`;
            await new Promise(res => {
                const blob = new Blob([svgStr], { type: 'image/svg+xml' });
                const url  = URL.createObjectURL(blob);
                const img  = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, offW, offH);
                    URL.revokeObjectURL(url);
                    res();
                };
                img.onerror = () => {
                    // Fallback: dark solid if SVG method fails
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(0, 0, offW, offH);
                    URL.revokeObjectURL(url);
                    res();
                };
                img.src = url;
            });
        } else {
            // Solid color (hex, rgb, named)
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, offW, offH);
        }

        // Layers ‚Äî scale relative to the correctly-sized offscreen canvas
        const canvasEl = document.getElementById('comic-frame');
        const scaleX = offW / canvasEl.offsetWidth;
        const scaleY = offH / canvasEl.offsetHeight;

        for (const l of f.layers) {
            if (l.type === 'img') {
                await new Promise(res => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        const h = l.w * (img.naturalHeight / img.naturalWidth) * scaleY;
                        const w = l.w * scaleX;
                        ctx.save();
                        ctx.translate((l.x * scaleX) + w/2, (l.y * scaleY) + h/2);
                        ctx.rotate(((l.rotation || 0) * Math.PI) / 180);
                        if (l.flipped) ctx.scale(-1, 1);
                        ctx.drawImage(img, -w/2, -h/2, w, h);
                        ctx.restore();
                        res();
                    };
                    img.onerror = res;
                    img.src = l.src;
                });
            } else {
                // Text / bubble layers
                const fs = (l.fontSize || 28) * scaleX;
                const ff = l.fontFamily || "'Inter', sans-serif";
                ctx.save();
                ctx.font = `${l.bold ? '900' : '700'} ${fs}px ${ff}`;
                ctx.fillStyle = l.color || '#000';
                ctx.textAlign = l.align || 'left';
                // Simple bubble box
                if (l.type === 'bubble' || l.type === 'thinking') {
                    const bx = l.x * scaleX, by = l.y * scaleY;
                    const bw = l.w * scaleX;
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2 * scaleX;
                    ctx.beginPath();
                    ctx.roundRect(bx, by, bw, fs * 2, 12 * scaleX);
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = l.color || '#000';
                    ctx.fillText(l.content || '', bx + 10 * scaleX, by + fs * 1.3, bw - 20 * scaleX);
                } else {
                    ctx.fillText(l.content || '', l.x * scaleX, (l.y + (l.fontSize || 28)) * scaleY, l.w * scaleX);
                }
                ctx.restore();
            }
        }
        return offscreen;
    }

    // ‚îÄ‚îÄ GIF Export ‚îÄ‚îÄ
    async function exportGIF() {
        const fps     = parseInt(document.getElementById('gif-fps').value);
        const quality = parseInt(document.getElementById('gif-quality').value);
        const delay   = Math.round(1000 / fps);
        const size    = 400; // GIF base size (longest edge)

        const btn      = document.getElementById('gif-export-btn');
        const status   = document.getElementById('gif-status');
        const bar      = document.getElementById('gif-progress-bar');
        const fill     = document.getElementById('gif-progress-fill');

        btn.disabled = true; btn.innerText = 'Building‚Ä¶';
        bar.style.display = 'block';
        status.innerText = 'Rendering frames‚Ä¶';

        try {
            // Determine GIF dimensions from ratio
            const ratio = canvasRatio ? (canvasRatio.w / canvasRatio.h) : 1;
            const gifW = ratio >= 1 ? size : Math.round(size * ratio);
            const gifH = ratio <= 1 ? size : Math.round(size / ratio);

            const gif = new GIF({
                workers: 2, quality,
                width: gifW, height: gifH,
                workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js'
            });

            for (let i = 0; i < frames.length; i++) {
                fill.style.width = Math.round((i / frames.length) * 60) + '%';
                status.innerText = `Rendering frame ${i+1} / ${frames.length}‚Ä¶`;
                const fc = await frameToCanvas(i, size);
                gif.addFrame(fc, { delay, copy: true });
            }

            fill.style.width = '70%';
            status.innerText = 'Encoding GIF‚Ä¶ (may take a moment)';

            gif.on('progress', p => { fill.style.width = (70 + p * 30) + '%'; });
            gif.on('finished', blob => {
                fill.style.width = '100%';
                status.innerText = 'Done! Downloading‚Ä¶';
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'comiccore.gif';
                a.click(); URL.revokeObjectURL(url);
                btn.disabled = false; btn.innerText = 'GENERATE GIF';
                bar.style.display = 'none'; fill.style.width = '0%';
                status.innerText = '‚úì GIF saved!';
            });

            gif.render();
        } catch(err) {
            status.innerText = 'Error: ' + err.message;
            btn.disabled = false; btn.innerText = 'GENERATE GIF';
        }
    }

    // ‚îÄ‚îÄ Comic Strip Export ‚îÄ‚îÄ
    async function exportStrip() {
        const cols     = parseInt(document.getElementById('strip-cols').value);
        const cellSize = 300; // longest edge of each frame cell in px
        const wmWidth  = 36;  // watermark sidebar width

        // Compute per-cell dimensions that respect canvasRatio
        const ratio  = canvasRatio ? (canvasRatio.w / canvasRatio.h) : 1;
        const cellW  = ratio >= 1 ? cellSize : Math.round(cellSize * ratio);
        const cellH  = ratio <= 1 ? cellSize : Math.round(cellSize / ratio);

        const rows   = Math.ceil(frames.length / cols);
        const totalW = cellW * cols + wmWidth;
        const totalH = cellH * rows;

        const btn    = document.getElementById('strip-export-btn');
        const status = document.getElementById('strip-status');
        btn.disabled = true; btn.innerText = 'Building‚Ä¶';
        status.innerText = 'Rendering frames‚Ä¶';

        try {
            const strip = document.createElement('canvas');
            strip.width  = totalW;
            strip.height = totalH;
            const ctx = strip.getContext('2d');

            // White background
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, totalW, totalH);

            // Draw each frame cell
            for (let i = 0; i < frames.length; i++) {
                status.innerText = `Rendering frame ${i+1} / ${frames.length}‚Ä¶`;
                const fc = await frameToCanvas(i, cellSize);
                const col = i % cols;
                const row = Math.floor(i / cols);
                ctx.drawImage(fc, col * cellW, row * cellH, cellW, cellH);
                // Cell border
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(col * cellW, row * cellH, cellW, cellH);
            }

            // ‚îÄ‚îÄ ComicCore watermark sidebar (right side) ‚îÄ‚îÄ
            const wmX = totalW - wmWidth;
            // Gradient background
            const grad = ctx.createLinearGradient(wmX, 0, totalW, totalH);
            grad.addColorStop(0, '#FF7A00');
            grad.addColorStop(1, '#ff4a00');
            ctx.fillStyle = grad;
            ctx.fillRect(wmX, 0, wmWidth, totalH);

            // Vertical text
            ctx.save();
            ctx.translate(wmX + wmWidth / 2, totalH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 13px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.letterSpacing = '3px';
            ctx.fillText('COMICCORE', 0, 5);
            ctx.restore();

            // Small logo dot
            ctx.beginPath();
            ctx.arc(wmX + wmWidth / 2, 22, 8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fill();

            // Download
            status.innerText = 'Saving‚Ä¶';
            const url = strip.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = url; a.download = 'comiccore-strip.png';
            a.click();

            btn.disabled = false; btn.innerText = 'SAVE STRIP';
            status.innerText = '‚úì Strip saved!';
        } catch(err) {
            status.innerText = 'Error: ' + err.message;
            btn.disabled = false; btn.innerText = 'SAVE STRIP';
        }
    }

    function addSubtitle() {
        const charName = prompt('Character name:', 'CHARACTER');
        if (charName === null) return;
        const dialogue = prompt('Dialogue:', 'What they say...');
        if (dialogue === null) return;
        saveState();
        const nl = {
            type: 'subtitle',
            characterName: charName.toUpperCase(),
            content: dialogue,
            color: '#111',
            nameColor: '#ff9500',
            x: Math.round((canvas.getBoundingClientRect().width  * 0.1)),
            y: Math.round((canvas.getBoundingClientRect().height * 0.75)),
            w: Math.round((canvas.getBoundingClientRect().width  * 0.8)),
            fontSize: 20,
            fontFamily: "'Inter', sans-serif",
            bold: false, italic: false, align: 'left',
        };
        frames[currentIdx].layers.push(nl);
        activeLayer = nl;
        render();
        setTimeout(() => showFloatToolbar(nl), 20);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BACKGROUND FILTER & TRANSFORM SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const BG_FILTERS = [
        { name: 'None',           css: 'none' },
        { name: 'Grayscale',      css: 'grayscale(100%)' },
        { name: 'Sepia',          css: 'sepia(80%)' },
        { name: 'Vivid',          css: 'saturate(200%) contrast(110%)' },
        { name: 'Vivid Warm',     css: 'saturate(200%) contrast(110%) hue-rotate(-10deg)' },
        { name: 'Vivid Cool',     css: 'saturate(200%) contrast(110%) hue-rotate(20deg)' },
        { name: 'Dramatic',       css: 'contrast(180%) brightness(85%)' },
        { name: 'Dramatic Warm',  css: 'contrast(180%) brightness(85%) sepia(30%)' },
        { name: 'Dramatic Cool',  css: 'contrast(180%) brightness(85%) hue-rotate(30deg)' },
        { name: 'Silvertone',     css: 'grayscale(100%) contrast(120%) brightness(110%)' },
        { name: 'Noir',           css: 'grayscale(100%) contrast(200%) brightness(70%)' },
        { name: 'Clarendon',      css: 'contrast(120%) saturate(125%)' },
        { name: 'Gingham',        css: 'brightness(105%) hue-rotate(-10deg) saturate(90%)' },
        { name: 'Juno',           css: 'saturate(160%) contrast(105%) sepia(20%)' },
        { name: 'Lark',           css: 'contrast(90%) brightness(110%) saturate(110%)' },
        { name: 'Lo-Fi',          css: 'saturate(150%) contrast(150%)' },
        { name: 'Ludwig',         css: 'sepia(25%) saturate(130%) brightness(105%)' },
        { name: 'Valencia',       css: 'sepia(35%) contrast(110%) brightness(108%) saturate(120%)' },
        { name: 'X-Pro II',       css: 'sepia(45%) saturate(180%) contrast(130%)' },
        { name: 'Hefe',           css: 'saturate(150%) contrast(140%) sepia(20%)' },
        { name: 'Inkwell',        css: 'grayscale(100%) sepia(20%) contrast(110%)' },
        { name: 'Teal & Orange',  css: 'saturate(130%) contrast(110%) hue-rotate(-15deg)' },
        { name: 'Matte',          css: 'contrast(85%) brightness(110%) saturate(80%)' },
        { name: 'Film Grain',     css: 'contrast(110%) brightness(95%) saturate(90%)' },
        { name: 'Light Leak',     css: 'brightness(115%) saturate(130%) hue-rotate(-5deg)' },
        { name: 'Kodachrome',     css: 'saturate(120%) contrast(110%) brightness(105%) sepia(15%)' },
        { name: 'Technicolor',    css: 'saturate(180%) contrast(115%) hue-rotate(5deg)' },
        { name: 'Soft Focus',     css: 'blur(1px) brightness(108%) saturate(110%)' },
        { name: 'Duotone',        css: 'grayscale(100%) sepia(100%) saturate(300%) hue-rotate(200deg)' },
        { name: 'Glitch',         css: 'saturate(200%) hue-rotate(45deg) contrast(150%)' },
        { name: 'HDR',            css: 'contrast(140%) saturate(140%) brightness(105%)' },
    ];

    function buildFilterChips() {
        const row = document.getElementById('filter-row');
        row.innerHTML = '';
        BG_FILTERS.forEach(f => {
            const chip = document.createElement('button');
            chip.className = 'filter-chip';
            chip.textContent = f.name;
            chip.dataset.css = f.css;
            chip.onclick = () => {
                document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
                if (!frames[currentIdx].bgSettings) frames[currentIdx].bgSettings = {};
                frames[currentIdx].bgSettings.filter = f.css;
                applyBgTransform();
            };
            row.appendChild(chip);
        });
    }

    function openBgPanel() {
        toggleMenu('plus-menu');
        const f = frames[currentIdx];
        if (!f.background || f.background === '#ffffff') {
            alert('Add a background image first!'); return;
        }
        buildFilterChips();
        const s = f.bgSettings || {};
        document.getElementById('bg-scale').value  = s.scale  ?? 100;
        document.getElementById('bg-rotate').value = s.rotate ?? 0;
        document.getElementById('bg-x').value      = Math.max(-50, Math.min(50, s.x ?? 0));
        document.getElementById('bg-y').value      = Math.max(-50, Math.min(50, s.y ?? 0));
        document.getElementById('bg-scale-num').value  = s.scale  ?? 100;
        document.getElementById('bg-x-num').value      = Math.max(-50, Math.min(50, s.x ?? 0));
        document.getElementById('bg-y-num').value      = Math.max(-50, Math.min(50, s.y ?? 0));
        document.getElementById('bg-rotate-val').innerText = (s.rotate ?? 0) + '¬∞';
        // Show re-crop only for non-GIF image backgrounds
        const isBgImage = f.background && (f.background.startsWith('http') || f.background.startsWith('data:image'));
        const isBgGif   = isBgImage && isAnimatedBg(f.background);
        document.getElementById('bg-recrop-btn').style.display = (isBgImage && !isBgGif) ? 'flex' : 'none';
        // Highlight current filter chip
        const currentFilter = s.filter || 'none';
        document.querySelectorAll('.filter-chip').forEach(c => {
            c.classList.toggle('active', c.dataset.css === currentFilter);
        });
        document.getElementById('bg-edit-panel').style.display = 'flex';
        // Show drag-to-pan overlay
        const overlay = document.getElementById('bg-drag-overlay');
        overlay.style.display = (isBgImage || f.background?.startsWith('linear') || f.background?.startsWith('radial')) ? 'block' : 'none';
    }

    function closeBgPanel() {
        document.getElementById('bg-edit-panel').style.display = 'none';
        document.getElementById('bg-drag-overlay').style.display = 'none';
    }

    function applyBgTransform() {
        if (!frames[currentIdx].bgSettings) frames[currentIdx].bgSettings = {};
        const s  = frames[currentIdx].bgSettings;
        s.scale  = parseInt(document.getElementById('bg-scale').value);
        s.rotate = parseInt(document.getElementById('bg-rotate').value);
        s.x      = parseInt(document.getElementById('bg-x').value);
        s.y      = parseInt(document.getElementById('bg-y').value);
        if (!s.filter) s.filter = 'none';
        // Sync number inputs
        document.getElementById('bg-scale-num').value  = s.scale;
        document.getElementById('bg-x-num').value      = s.x;
        document.getElementById('bg-y-num').value      = s.y;
        document.getElementById('bg-rotate-val').innerText = s.rotate + '¬∞';
        // Apply to all frames if checkbox checked
        if (document.getElementById('bg-apply-all').checked) {
            frames.forEach(f => {
                if (!f.bgSettings) f.bgSettings = {};
                Object.assign(f.bgSettings, { scale: s.scale, rotate: s.rotate, x: s.x, y: s.y });
            });
        }
        renderBgStyles();
    }

    function renderBgStyles() {
        // Just call render() ‚Äî it rebuilds the bg-layer correctly including filter
        render();
    }

    function resetBgTransform() {
        frames[currentIdx].bgSettings = { scale: 100, rotate: 0, x: 0, y: 0, filter: 'none' };
        document.getElementById('bg-scale').value  = 100;
        document.getElementById('bg-rotate').value = 0;
        document.getElementById('bg-x').value      = 0;
        document.getElementById('bg-y').value      = 0;
        document.getElementById('bg-scale-num').value = 100;
        document.getElementById('bg-x-num').value = 0;
        document.getElementById('bg-y-num').value = 0;
        document.querySelectorAll('.filter-chip').forEach((c,i) => c.classList.toggle('active', i === 0));
        applyBgTransform();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BG DRAG-TO-PAN (canvas overlay)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    (function initBgDrag() {
        // Wait for DOM ready
        document.addEventListener('DOMContentLoaded', setupBgDrag);
        // Also try immediately (script may run after DOMContentLoaded)
        if (document.readyState !== 'loading') setTimeout(setupBgDrag, 0);

        function setupBgDrag() {
            const overlay = document.getElementById('bg-drag-overlay');
            if (!overlay) return;
            let dragging = false, startX = 0, startY = 0, startBgX = 0, startBgY = 0;

            // The X/Y sliders have range -50..50, which maps to 0-100% bg-position offset from center.
            // Drag sensitivity: canvas ~600px, slider range 100 units ‚Üí 100/600 ‚âà 0.17 units/px
            const SENSITIVITY = 0.17;

            function getStartVals() {
                startBgX = parseInt(document.getElementById('bg-x').value) || 0;
                startBgY = parseInt(document.getElementById('bg-y').value) || 0;
            }

            function clamp(v, mn, mx) { return Math.max(mn, Math.min(mx, v)); }

            overlay.addEventListener('mousedown', e => {
                if (e.button !== 0) return;
                dragging = true;
                startX = e.clientX; startY = e.clientY;
                getStartVals();
                overlay.classList.add('dragging');
                overlay.querySelector('.drag-hint').style.opacity = '0';
                e.preventDefault();
                e.stopPropagation();
            });

            overlay.addEventListener('touchstart', e => {
                dragging = true;
                startX = e.touches[0].clientX; startY = e.touches[0].clientY;
                getStartVals();
                overlay.classList.add('dragging');
                overlay.querySelector('.drag-hint').style.opacity = '0';
                e.preventDefault();
                e.stopPropagation();
            }, { passive: false });

            function onMove(dx, dy) {
                if (!dragging) return;
                const newX = clamp(Math.round(startBgX + dx * SENSITIVITY), -50, 50);
                const newY = clamp(Math.round(startBgY + dy * SENSITIVITY), -50, 50);
                document.getElementById('bg-x').value       = newX;
                document.getElementById('bg-x-num').value   = newX;
                document.getElementById('bg-y').value       = newY;
                document.getElementById('bg-y-num').value   = newY;
                if (!frames[currentIdx].bgSettings) frames[currentIdx].bgSettings = {};
                frames[currentIdx].bgSettings.x = newX;
                frames[currentIdx].bgSettings.y = newY;
                renderBgStyles();
            }

            document.addEventListener('mousemove', e => {
                if (!dragging) return;
                onMove(e.clientX - startX, e.clientY - startY);
            });
            document.addEventListener('touchmove', e => {
                if (!dragging) return;
                onMove(e.touches[0].clientX - startX, e.touches[0].clientY - startY);
            }, { passive: true });

            function endDrag() {
                if (!dragging) return;
                dragging = false;
                overlay.classList.remove('dragging');
                overlay.querySelector('.drag-hint').style.opacity = '0.8';
            }
            document.addEventListener('mouseup',  endDrag);
            document.addEventListener('touchend', endDrag);
        }
    })();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SPRITE BLUR SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function setSpriteBlur(type) {
        if (!activeLayer || activeLayer.type !== 'img') return;
        saveState();
        activeLayer.blurType   = type;
        activeLayer.blurAmount = parseInt(document.getElementById('blur-amount').value) || 4;
        // Update button states
        ['none','soft','pixel'].forEach(t => {
            document.getElementById('blur-' + t + '-btn').classList.toggle('active', t === type);
        });
        const amtRow = document.getElementById('blur-amount-row');
        amtRow.style.display = type === 'none' ? 'none' : 'flex';
        render();
    }

    function updateSpriteBlur() {
        if (!activeLayer) return;
        const amt = parseInt(document.getElementById('blur-amount').value);
        document.getElementById('blur-amount-val').innerText = amt + 'px';
        activeLayer.blurAmount = amt;
        render();
    }

    function getSpriteFilterCSS(layer) {
        if (!layer.blurType || layer.blurType === 'none') return '';
        const amt = layer.blurAmount || 4;
        if (layer.blurType === 'soft') return `blur(${amt}px)`;
        if (layer.blurType === 'pixel') {
            // Pixelate simulation: tiny scale down ‚Üí upscale makes pixel blocks
            // We use blur + contrast to fake pixel look via CSS
            // More robust: use canvas for real pixelation, but CSS approach for realtime editing
            return `blur(${Math.max(1, Math.round(amt * 0.6))}px) contrast(${100 + amt * 4}%) saturate(120%)`;
        }
        return '';
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SPRITE NAME TAG SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateNameTag(val) {
        if (!activeLayer) return;
        activeLayer.nameTag = val;
        render();
    }

    function clearNameTag() {
        if (!activeLayer) return;
        activeLayer.nameTag = '';
        document.getElementById('sprite-nametag-input').value = '';
        render();
    }

    function saveSpriteToPersonal() {
        if (!activeLayer || activeLayer.type !== 'img') return;
        const profile = JSON.parse(localStorage.getItem('user_profile') || '{}');
        if (!profile.handle) return alert('Log in to save sprites.');
        const name = activeLayer.nameTag || prompt('Name for this sprite:', 'My Sprite');
        if (!name) return;
        const pack = {
            name,
            image_data: activeLayer.src,
            actions: activeLayer.packData?.actions || {}
        };
        localStorage.setItem('save_sprite_to_personal', JSON.stringify(pack));
        // Save directly via supabase without navigating away
        _supabase.from('user_sprites').insert([{
            owner_handle: profile.handle,
            name: pack.name,
            image_data: pack.image_data,
            actions: pack.actions
        }]).then(({ error }) => {
            if (error) alert('Error saving: ' + error.message);
            else {
                localStorage.removeItem('save_sprite_to_personal');
                // Brief confirmation flash
                const flash = document.createElement('div');
                flash.style.cssText = 'position:fixed;bottom:120px;left:50%;transform:translateX(-50%);background:var(--teal);color:#000;padding:8px 20px;border-radius:10px;font-weight:900;font-size:12px;z-index:9999;pointer-events:none;';
                flash.innerText = '‚úÖ Saved to Your Sprites!';
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 2500);
            }
        });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MULTI-FRAME IMPORT SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let multiImportFiles = []; // stores {dataUrl, name} objects

    function openMultiImport() {
        toggleMenu('plus-menu');
        multiImportFiles = [];
        document.getElementById('multi-preview-grid').innerHTML = '';
        document.getElementById('multi-ratio-warning').style.display = 'none';
        document.getElementById('multi-confirm-btn').disabled = true;
        if (canvasRatio) {
            document.getElementById('multi-ratio-hint').innerText = canvasRatio.w + ':' + canvasRatio.h;
        }
        document.getElementById('multi-import-modal').style.display = 'flex';
        // Drag-and-drop support
        const zone = document.getElementById('multi-drop-zone');
        zone.ondragover  = e => { e.preventDefault(); zone.classList.add('dragover'); };
        zone.ondragleave = ()  => zone.classList.remove('dragover');
        zone.ondrop      = e  => {
            e.preventDefault(); zone.classList.remove('dragover');
            handleMultiFiles(e.dataTransfer.files);
        };
    }

    function closeMultiImport() { document.getElementById('multi-import-modal').style.display = 'none'; }

    function handleMultiFiles(fileList) {
        if (!fileList || fileList.length === 0) return;
        const files = Array.from(fileList).filter(f => f.type.startsWith('image/'));
        const grid = document.getElementById('multi-preview-grid');
        let ratioWarning = false;

        files.forEach((file, idx) => {
            const reader = new FileReader();
            reader.onload = e => {
                const dataUrl = e.target.result;
                // Check aspect ratio
                const img = new Image();
                img.onload = () => {
                    const imgRatio = img.naturalWidth / img.naturalHeight;
                    const canvasR  = canvasRatio ? (canvasRatio.w / canvasRatio.h) : 1;
                    if (Math.abs(imgRatio - canvasR) > 0.05) ratioWarning = true;
                    if (ratioWarning) document.getElementById('multi-ratio-warning').style.display = 'block';
                };
                img.src = dataUrl;

                multiImportFiles.push({ dataUrl, name: file.name });
                // Sort by name (natural sort so frame1 < frame2 < frame10)
                multiImportFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

                // Re-render preview
                grid.innerHTML = '';
                multiImportFiles.forEach((f, i) => {
                    const div = document.createElement('div');
                    div.className = 'multi-thumb';
                    div.style.backgroundImage = `url(${f.dataUrl})`;
                    div.innerHTML = `<div class="order-badge">${i + 1}</div>`;
                    grid.appendChild(div);
                });
                document.getElementById('multi-confirm-btn').disabled = multiImportFiles.length === 0;
            };
            reader.readAsDataURL(file);
        });
    }

    function confirmMultiImport() {
        if (multiImportFiles.length === 0) return;
        saveState();
        const mode = document.getElementById('multi-insert-mode').value;
        const canvasR = canvasRatio ? (canvasRatio.w / canvasRatio.h) : 1;

        const newFrames = multiImportFiles.map(f => ({
            layers: [],
            background: f.dataUrl,
            bgSettings: { scale: 100, rotate: 0, x: 0, y: 0, filter: 'none' }
        }));

        if (mode === 'replace') {
            frames = newFrames;
            currentIdx = 0;
        } else if (mode === 'append') {
            frames.splice(currentIdx + 1, 0, ...newFrames);
            currentIdx = currentIdx + 1;
        } else if (mode === 'from-current') {
            frames.splice(currentIdx, frames.length - currentIdx, ...newFrames);
        }

        closeMultiImport();
        multiImportFiles = [];
        render();
        alert(`‚úÖ Imported ${newFrames.length} frames!`);
    }
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FX PANEL ‚Äî layer-level blur + filter + opacity (multi-select)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const LAYER_FILTERS = [
        { name: 'None',        css: 'none' },
        { name: 'Grayscale',   css: 'grayscale(100%)' },
        { name: 'Sepia',       css: 'sepia(80%)' },
        { name: 'Vivid',       css: 'saturate(200%) contrast(110%)' },
        { name: 'Vivid Warm',  css: 'saturate(200%) contrast(110%) hue-rotate(-10deg)' },
        { name: 'Vivid Cool',  css: 'saturate(200%) contrast(110%) hue-rotate(20deg)' },
        { name: 'Dramatic',    css: 'contrast(180%) brightness(85%)' },
        { name: 'Noir',        css: 'grayscale(100%) contrast(200%) brightness(70%)' },
        { name: 'Clarendon',   css: 'contrast(120%) saturate(125%)' },
        { name: 'Lark',        css: 'contrast(90%) brightness(110%) saturate(110%)' },
        { name: 'Lo-Fi',       css: 'saturate(150%) contrast(150%)' },
        { name: 'Valencia',    css: 'sepia(35%) contrast(110%) brightness(108%) saturate(120%)' },
        { name: 'Duotone',     css: 'grayscale(100%) sepia(100%) saturate(300%) hue-rotate(200deg)' },
        { name: 'Glitch',      css: 'saturate(200%) hue-rotate(45deg) contrast(150%)' },
        { name: 'HDR',         css: 'contrast(140%) saturate(140%) brightness(105%)' },
        { name: 'Technicolor', css: 'saturate(180%) contrast(115%) hue-rotate(5deg)' },
        { name: 'Teal+Orange', css: 'saturate(130%) contrast(110%) hue-rotate(-15deg)' },
        { name: 'Matte',       css: 'contrast(85%) brightness(110%) saturate(80%)' },
    ];

    function buildFxFilterChips() {
        const row = document.getElementById('fx-filter-row');
        if (row.children.length > 0) return; // already built
        LAYER_FILTERS.forEach(f => {
            const chip = document.createElement('button');
            chip.className = 'fx-chip';
            chip.textContent = f.name;
            chip.dataset.css = f.css;
            if (f.css === 'none') chip.classList.add('active');
            chip.onclick = () => {
                row.querySelectorAll('.fx-chip').forEach(ch => ch.classList.remove('active'));
                chip.classList.add('active');
                applyFxToSelected();
            };
            row.appendChild(chip);
        });
    }

    function toggleFxPanel() {
        const panel = document.getElementById('fx-panel');
        const isOpen = panel.style.display === 'flex';
        if (isOpen) { closeFxPanel(); return; }
        buildFxFilterChips();
        panel.style.display = 'flex';
        document.getElementById('fx-btn').classList.add('active-tool');
        // Sync UI to first selected layer
        const target = selectedLayers[0] || activeLayer;
        syncFxToLayer(target);
        updateFxHint();
    }

    function closeFxPanel() {
        document.getElementById('fx-panel').style.display = 'none';
        document.getElementById('fx-btn').classList.remove('active-tool');
    }

    function syncFxToLayer(layer) {
        if (!layer) return;
        const bType = layer.blurType  || 'none';
        const bAmt  = layer.blurAmount || 4;
        const fCss  = layer.layerFilter || 'none';
        const opacity = layer.opacity != null ? layer.opacity : 100;

        ['none','soft','pixel'].forEach(t => {
            document.getElementById('fx-blur-' + t).classList.toggle('active', t === bType);
        });
        document.getElementById('fx-blur-amt').value     = bAmt;
        document.getElementById('fx-blur-amt-val').innerText = bAmt + 'px';
        document.getElementById('fx-blur-amt-row').style.display = bType === 'none' ? 'none' : 'flex';
        document.getElementById('fx-opacity').value      = opacity;
        document.getElementById('fx-opacity-val').innerText = opacity + '%';

        // Highlight matching filter chip
        document.querySelectorAll('.fx-chip').forEach(ch => {
            ch.classList.toggle('active', ch.dataset.css === fCss);
        });
    }

    function updateFxHint() {
        const hint = document.getElementById('fx-selected-hint');
        const count = selectedLayers.length || (activeLayer ? 1 : 0);
        hint.innerText = count
            ? count + ' layer' + (count > 1 ? 's' : '') + ' selected'
            : 'Tap LAYERS and select layer(s) first';
        hint.style.color = count ? 'var(--teal)' : '#555';
    }

    function setFxBlur(type) {
        document.getElementById('fx-blur-amt-row').style.display = type === 'none' ? 'none' : 'flex';
        ['none','soft','pixel'].forEach(t => {
            document.getElementById('fx-blur-' + t).classList.toggle('active', t === type);
        });
        applyFxToSelected();
    }

    function applyFxToSelected() {
        saveState();
        const targets = selectedLayers.length ? selectedLayers : (activeLayer ? [activeLayer] : []);
        if (!targets.length) return;

        const blurType   = ['none','soft','pixel'].find(t => document.getElementById('fx-blur-' + t).classList.contains('active')) || 'none';
        const blurAmount = parseInt(document.getElementById('fx-blur-amt').value);
        const filterCss  = [...document.querySelectorAll('#fx-filter-row .fx-chip')].find(ch => ch.classList.contains('active'))?.dataset.css || 'none';
        const opacity    = parseInt(document.getElementById('fx-opacity').value);

        document.getElementById('fx-blur-amt-val').innerText = blurAmount + 'px';
        document.getElementById('fx-opacity-val').innerText  = opacity + '%';

        targets.forEach(layer => {
            layer.blurType    = blurType;
            layer.blurAmount  = blurAmount;
            layer.layerFilter = filterCss;
            layer.opacity     = opacity;
        });
        render();
    }

    function clearFxFromSelected() {
        saveState();
        const targets = selectedLayers.length ? selectedLayers : (activeLayer ? [activeLayer] : []);
        targets.forEach(layer => {
            layer.blurType    = 'none';
            layer.blurAmount  = 4;
            layer.layerFilter = 'none';
            layer.opacity     = 100;
        });
        syncFxToLayer(targets[0]);
        render();
    }

</script>

<!-- ‚îÄ‚îÄ Sidebar JS ‚îÄ‚îÄ -->
<script>
    let activeSidePanel = null;
    let sidebarSprites = null;

    function toggleSidePanel(name) {
        const panel = document.getElementById('sidebar-panel');
        // Close if same panel clicked
        if (activeSidePanel === name) {
            panel.classList.remove('open');
            document.querySelectorAll('.sp-content').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.sb-icon-btn[data-panel]').forEach(b => b.classList.remove('active'));
            activeSidePanel = null;
            return;
        }
        // Open new panel
        activeSidePanel = name;
        panel.classList.add('open');
        document.querySelectorAll('.sp-content').forEach(c => c.classList.remove('active'));
        document.querySelectorAll('.sb-icon-btn[data-panel]').forEach(b => b.classList.remove('active'));
        const content = document.getElementById('sp-' + name);
        if (content) content.classList.add('active');
        const btn = document.querySelector('.sb-icon-btn[data-panel="' + name + '"]');
        if (btn) btn.classList.add('active');
        // Panel-specific init
        if (name === 'sprites' && !sidebarSprites) loadSidebarSprites();
        if (name === 'layers') renderSidebarLayers();
    }

    // ‚îÄ‚îÄ Sprite Sidebar: metadata cache (localStorage, 10min TTL) ‚îÄ‚îÄ
    const SB_META_KEY = 'cc_sprites_meta_v2';
    const SB_META_TTL = 10 * 60 * 1000;

    function sbSaveMetaCache(data) {
        try { localStorage.setItem(SB_META_KEY, JSON.stringify({ ts: Date.now(), data })); } catch(e) {}
    }
    function sbLoadMetaCache() {
        try {
            const raw = localStorage.getItem(SB_META_KEY);
            if (!raw) return null;
            const p = JSON.parse(raw);
            if (Date.now() - p.ts > SB_META_TTL) { localStorage.removeItem(SB_META_KEY); return null; }
            return p.data;
        } catch(e) { return null; }
    }

    // Per-session image cache (sessionStorage) keyed by sprite id
    function sbGetImg(id) { try { return sessionStorage.getItem('cc_simg_' + id); } catch(e) { return null; } }
    function sbSetImg(id, b64) { try { sessionStorage.setItem('cc_simg_' + id, b64); } catch(e) {} }

    const SB_FULL_TTL = 30 * 60 * 1000;
    function sbGetFullCache(id) {
        try {
            const raw = localStorage.getItem('sb-full-' + id);
            if (!raw) return null;
            const p = JSON.parse(raw);
            if (Date.now() - (p.ts || 0) > SB_FULL_TTL) { localStorage.removeItem('sb-full-' + id); return null; }
            return p;
        } catch(e) { return null; }
    }
    function sbSetFullCache(id, imageData, actions) {
        try { localStorage.setItem('sb-full-' + id, JSON.stringify({ img: imageData, actions: actions || {}, ts: Date.now() })); } catch(e) {}
    }

    // Full data cache (image_data + actions) ‚Äî in-memory + localStorage backed
    const sbFullCache = new Map();

    async function sbFetchFull(id) {
        if (sbFullCache.has(id)) return sbFullCache.get(id);

        // localStorage hit ‚Äî zero network call
        const lsCached = sbGetFullCache(id);
        if (lsCached) {
            const result = { id, image_data: lsCached.img, actions: lsCached.actions };
            sbFullCache.set(id, result);
            const sp = (sidebarSprites || []).find(s => s.id === id);
            if (sp) { sp.image_data = lsCached.img; sp.actions = lsCached.actions; }
            sbSetImg(id, lsCached.img);
            return result;
        }

        const { data } = await _supabase.from('sprites_library')
            .select('id, image_data, actions').eq('id', id).single();
        if (data) {
            sbFullCache.set(id, data);
            const sp = (sidebarSprites || []).find(s => s.id === id);
            if (sp) { sp.image_data = data.image_data; sp.actions = data.actions; }
            sbSetImg(id, data.image_data);
            sbSetFullCache(id, data.image_data, data.actions);
        }
        return data;
    }

    // Lazy-load batch queue for the sidebar grid
    let sbLazyQueue = [];
    let sbLazyTimer = null;

    const sbObserver = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (!entry.isIntersecting) return;
            sbObserver.unobserve(entry.target);
            const id = entry.target.dataset.sid;
            if (!id) return;
            const cached = sbGetImg(id);
            if (cached) {
                sbApplyImg(entry.target, cached);
            } else {
                sbLazyQueue.push(id);
                sbScheduleBatch();
            }
        });
    }, { root: document.getElementById('sb-sprite-grid'), rootMargin: '200px 0px' });

    function sbScheduleBatch() {
        if (sbLazyTimer) return;
        sbLazyTimer = setTimeout(sbFlushBatch, 40);
    }

    async function sbFlushBatch() {
        sbLazyTimer = null;
        if (!sbLazyQueue.length) return;
        const batch = [...new Set(sbLazyQueue.splice(0, 20))];
        const { data } = await _supabase.from('sprites_library')
            .select('id, image_data').in('id', batch);
        if (!data) return;
        data.forEach(row => {
            sbSetImg(row.id, row.image_data);
            const sp = (sidebarSprites || []).find(s => s.id === row.id);
            if (sp) sp.image_data = row.image_data;
            const card = document.querySelector(`.sb-sprite-card[data-sid="${row.id}"]`);
            if (card) sbApplyImg(card, row.image_data);
        });
        if (sbLazyQueue.length) sbScheduleBatch();
    }

    function sbApplyImg(card, src) {
        const skeleton = card.querySelector('.sb-skeleton');
        if (!skeleton) return;
        const img = document.createElement('img');
        img.className = 'sb-loaded';
        img.onload = () => skeleton.replaceWith(img);
        img.onerror = () => skeleton.style.background = '#1a1a1a';
        img.src = src;
    }

    async function loadSidebarSprites() {
        const grid = document.getElementById('sb-sprite-grid');

        // 1. Serve from cache instantly
        const cached = sbLoadMetaCache();
        if (cached) {
            sidebarSprites = cached;
            renderSidebarSprites(sidebarSprites);
        } else {
            grid.innerHTML = '<div class="sp-load-msg">Loading sprites...</div>';
        }

        // 2. Refresh metadata from DB in background
        try {
            const { data } = await _supabase.from('sprites_library')
                .select('id, name, tags, creator, created_at')
                .order('created_at', { ascending: false });
            const fresh = data || [];

            // Only re-render if data changed
            const cachedIds = (sidebarSprites || []).map(s => s.id).join(',');
            const freshIds  = fresh.map(s => s.id).join(',');
            if (freshIds !== cachedIds || !cached) {
                sidebarSprites = fresh;
                sbSaveMetaCache(fresh);
                renderSidebarSprites(sidebarSprites);
            }
        } catch(e) {
            if (!cached) grid.innerHTML = '<div class="sp-load-msg">Error loading sprites</div>';
        }
    }

    function renderSidebarSprites(sprites) {
        const grid = document.getElementById('sb-sprite-grid');
        const q = (document.getElementById('sb-sprite-search')?.value || '').toLowerCase().trim();
        const filtered = q ? sprites.filter(s =>
            s.name.toLowerCase().includes(q) ||
            (s.tags || []).some(t => t.includes(q))
        ) : sprites;

        if (!filtered.length) {
            grid.innerHTML = '<div class="sp-load-msg">No sprites found</div>'; return;
        }

        grid.innerHTML = '';
        filtered.forEach(pack => {
            const div = document.createElement('div');
            div.className = 'sb-sprite-card';
            div.dataset.sid = pack.id;

            const cachedSrc = pack.image_data || sbGetImg(pack.id);
            if (cachedSrc) {
                div.innerHTML = `<img class="sb-loaded" src="${cachedSrc}"><span>${pack.name}</span>`;
            } else {
                div.innerHTML = `<div class="sb-skeleton"></div><span>${pack.name}</span>`;
                sbObserver.observe(div);
            }

            div.onclick = async () => {
                // Need full data (image_data + actions) before opening modal
                const hasFull = pack.image_data && pack.actions !== undefined;
                if (hasFull) {
                    openActionModal(pack);
                } else {
                    // Show quick loading state on the card
                    div.style.opacity = '0.5';
                    const full = await sbFetchFull(pack.id);
                    div.style.opacity = '';
                    if (full) openActionModal({ ...pack, ...full });
                }
            };

            grid.appendChild(div);
        });
    }

    function filterSidebarSprites() {
        if (!sidebarSprites) return;
        renderSidebarSprites(sidebarSprites);
    }

    function renderSidebarLayers() {
        const container = document.getElementById('sb-layer-list');
        if (!container) return;
        container.innerHTML = '';
        const layerIcons = { img: 'üñº', bubble: 'üí¨', thinking: 'üí≠', text: '‚úçÔ∏è', subtitle: 'üìã' };
        [...frames[currentIdx].layers].reverse().forEach((l) => {
            const item = document.createElement('div');
            item.className = 'sb-layer-item';
            const isActive = activeLayer?.id === l.id;
            const isInSel = selectedLayers.some(s => s.id === l.id);
            if (isActive) item.classList.add('active-l');
            if (isInSel) item.classList.add('multi-l');
            if (l.locked) item.classList.add('locked-l');
            const icon = layerIcons[l.type] || '‚ñ´Ô∏è';
            const label = l.nameTag || (l.content ? l.content.substring(0, 18) : (l.type.toUpperCase()));
            // Lock button
            const lockBtn = document.createElement('button');
            lockBtn.className = 'lock-btn';
            lockBtn.title = l.locked ? 'Unlock layer' : 'Lock layer';
            lockBtn.innerText = l.locked ? 'üîí' : 'üîì';
            lockBtn.onclick = (e) => { e.stopPropagation(); toggleLayerLock(l.id); };

            item.innerHTML = '<span class="sb-layer-icon">' + icon + '</span><span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + label + '</span>';
            item.appendChild(lockBtn);
            item.onclick = (e) => {
                if (e.target === lockBtn) return;
                if (l.locked) return; // Don't select locked layers
                if (e.shiftKey || e.ctrlKey || e.metaKey) {
                    const idx = selectedLayers.findIndex(s => s.id === l.id);
                    if (idx === -1) selectedLayers.push(l); else selectedLayers.splice(idx, 1);
                } else {
                    selectedLayers = [l];
                    activeLayer = l;
                }
                render();
                renderSidebarLayers();
                if (typeof updateFxHint === 'function') updateFxHint();
            };
            container.appendChild(item);
        });
        if (!container.children.length) {
            container.innerHTML = '<div style="text-align:center;padding:20px;color:#333;font-size:11px;font-weight:700;">No layers yet</div>';
        }
    }

    // Override renderLayerList to also update sidebar
    const _origRenderLayerList = renderLayerList;
    function renderLayerList() {
        _origRenderLayerList();
        renderSidebarLayers();
    }

    function sbEditAction() {
        toggleTransform();
        // Visual feedback
        const btn = document.querySelector('.sb-icon-btn[data-action="edit"]');
        if (btn) btn.classList.toggle('active');
    }

    function sbTriggerActions() {
        if (activeLayer && activeLayer.packData) {
            editCurrentSpriteAction();
        } else {
            // Flash a hint if no sprite is selected
            showKbFlash('Select a sprite first to change its action/pose');
        }
    }

    function sbCopyLayer() {
        copyLayer();
    }
    function sbPasteLayer() {
        pasteLayer();
    }

    // Auto-refresh sidebar layers when render() runs
    const _origRender = render;
    render = function() {
        _origRender();
        if (activeSidePanel === 'layers') renderSidebarLayers();
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // KEYBOARD SHORTCUTS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    document.addEventListener('keydown', e => {
        // Never intercept when typing in an input/textarea/select
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
        // Don't intercept when an overlay modal is open (export, publish, etc.)
        const anyModalOpen = ['library-modal','action-modal','publish-modal','crop-modal','bg-import-choice-modal','export-modal','multi-import-modal']
            .some(id => { const el = document.getElementById(id); return el && (el.style.display === 'flex' || el.style.display === 'block'); });
        if (anyModalOpen) return;

        const ctrl = e.ctrlKey || e.metaKey;

        // ‚îÄ‚îÄ Undo / Redo ‚îÄ‚îÄ
        if (ctrl && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); showKbFlash('‚Ü© Undo'); return; }
        if (ctrl && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) { e.preventDefault(); redo(); showKbFlash('‚Ü™ Redo'); return; }

        // ‚îÄ‚îÄ Copy  (Ctrl+C) ‚îÄ‚îÄ
        if (ctrl && e.key === 'c') {
            e.preventDefault();
            if (activeLayer) {
                layerClipboard = JSON.parse(JSON.stringify(activeLayer));
                showKbFlash('üìÑ Layer copied!');
            } else {
                copyBackground();
            }
            return;
        }

        // ‚îÄ‚îÄ Paste  (Ctrl+V) ‚îÄ‚îÄ
        if (ctrl && e.key === 'v') {
            e.preventDefault();
            if (layerClipboard) {
                pasteLayer();
                showKbFlash('üìã Layer pasted!');
            } else if (bgClipboard) {
                pasteBackground();
            } else {
                showKbFlash('Clipboard is empty');
            }
            return;
        }

        // ‚îÄ‚îÄ Duplicate  (Ctrl+D) ‚Äî works for layers AND backgrounds/frames ‚îÄ‚îÄ
        if (ctrl && e.key === 'd') {
            e.preventDefault();
            if (activeLayer) {
                // Duplicate the selected layer
                saveState();
                const copy = JSON.parse(JSON.stringify(activeLayer));
                copy.id = Date.now();
                copy.x = Math.min((copy.x || 0) + 15, canvas.getBoundingClientRect().width  - (copy.w || 100));
                copy.y = Math.min((copy.y || 0) + 15, canvas.getBoundingClientRect().height - (copy.w || 100));
                frames[currentIdx].layers.push(copy);
                activeLayer = copy;
                render();
                if (['text','bubble','thinking','subtitle'].includes(copy.type)) showFloatToolbar(copy);
                showKbFlash('‚ßâ Layer duplicated!');
            } else {
                // Duplicate the entire frame (background + layers)
                duplicateFrame();
                showKbFlash('‚ßâ Frame duplicated!');
            }
            return;
        }

        // ‚îÄ‚îÄ Delete layer or background  (Delete / Backspace) ‚îÄ‚îÄ
        if (e.key === 'Delete' || e.key === 'Backspace') {
            if (activeLayer) {
                e.preventDefault();
                deleteLayer();
                showKbFlash('üóë Layer deleted');
            }
            // (Don't auto-delete background on plain Delete ‚Äî too destructive)
            return;
        }

        // ‚îÄ‚îÄ Arrow keys: navigate frames ‚îÄ‚îÄ
        if (e.key === 'ArrowRight') {
            e.preventDefault();
            const wasAtEnd = currentIdx >= frames.length - 1;
            nextFrame(); // already creates new frame if at end
            if (wasAtEnd && frames.length > 1) {
                showKbFlash(`‚ú® New frame created (${frames.length})`);
            } else {
                showKbFlash(`‚ñ∂ Frame ${currentIdx + 1} / ${frames.length}`);
            }
            return;
        }
        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            prevFrame();
            showKbFlash(`‚óÄ Frame ${currentIdx + 1} / ${frames.length}`);
            return;
        }

        // ‚îÄ‚îÄ Escape: close panels ‚îÄ‚îÄ
        if (e.key === 'Escape') {
            if (activeSidePanel) toggleSidePanel(activeSidePanel);
            return;
        }

        // ‚îÄ‚îÄ H: toggle UI visibility ‚îÄ‚îÄ
        if (e.key === 'h' || e.key === 'H') {
            const app = document.getElementById('cc-app');
            if (app.style.visibility === 'hidden') showEditorUI(); else hideEditorUI();
            return;
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HIDE / SHOW EDITOR UI
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function hideEditorUI() {
        const app = document.getElementById('cc-app');
        app.style.visibility = 'hidden';
        // Keep only the canvas visible ‚Äî viewport is inside cc-app so we need a different approach
        // Instead: hide top-bar, sidebars, frame-strip; show viewport but hide chrome
        app.querySelectorAll('#top-bar, #left-sidebar, #frame-strip').forEach(el => {
            el.style.display = 'none';
        });
        // Expand work-area to fill screen
        const wa = document.getElementById('work-area');
        if (wa) wa.style.height = '100vh';
        app.style.visibility = 'visible';
        document.getElementById('ui-reveal-btn').style.display = 'flex';
    }

    function showEditorUI() {
        const app = document.getElementById('cc-app');
        app.querySelectorAll('#top-bar, #left-sidebar, #frame-strip').forEach(el => {
            el.style.display = '';
        });
        const wa = document.getElementById('work-area');
        if (wa) wa.style.height = '';
        document.getElementById('ui-reveal-btn').style.display = 'none';
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // LAYER LOCK SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function toggleLayerLock(layerId) {
        const layer = frames[currentIdx].layers.find(l => l.id === layerId);
        if (!layer) return;
        layer.locked = !layer.locked;
        // If we just locked the active layer, deselect it
        if (layer.locked && activeLayer && activeLayer.id === layerId) {
            activeLayer = null;
        }
        render();
        renderSidebarLayers();
    }

    function toggleSelectedLayerLock() {
        if (!activeLayer) return;
        toggleLayerLock(activeLayer.id);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SELECTION OUTLINE OPACITY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateSelectionOpacity(val) {
        const opacity = parseInt(val) / 100;
        document.getElementById('sel-opacity-val').innerText = val + '%';
        // Apply via CSS: we override the active layer outline using injected style
        let styleEl = document.getElementById('sel-opacity-style');
        if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'sel-opacity-style';
            document.head.appendChild(styleEl);
        }
        const hex = Math.round(opacity * 255).toString(16).padStart(2, '0');
        styleEl.textContent = `.layer.active { outline: 2px solid #ff7a00${hex} !important; outline-offset: 1px; }`;
        localStorage.setItem('cc-sel-opacity', val);
    }

    function toggleEditorPrefs() {
        const panel = document.getElementById('editor-prefs-panel');
        panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
    }
    function closeEditorPrefs() {
        document.getElementById('editor-prefs-panel').style.display = 'none';
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BG RECROP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function openBgRecrop() {
        const f = frames[currentIdx];
        if (!f.background || (!f.background.startsWith('http') && !f.background.startsWith('data:image'))) return;
        currentImportType = 'bg';
        pendingBgImageSrc = f.background;
        const target = document.getElementById('crop-target');
        const ratio = canvasRatio ? (canvasRatio.w / canvasRatio.h) : 1;
        const initCropper = () => {
            if (cropper) cropper.destroy();
            cropper = new Cropper(target, { aspectRatio: ratio, viewMode: 1 });
        };
        document.getElementById('bg-edit-panel').style.display = 'none';
        document.getElementById('crop-modal').style.display = 'flex';
        target.onload = initCropper;
        if (target.src === f.background && target.complete) initCropper();
        else target.src = f.background;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INIT SAVED PREFERENCES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    (function initEditorPrefs() {
        const savedOpacity = localStorage.getItem('cc-sel-opacity');
        if (savedOpacity !== null) {
            document.getElementById('sel-opacity-slider').value = savedOpacity;
            updateSelectionOpacity(savedOpacity);
        }
    })();

    // ‚îÄ‚îÄ Draggable Transform UI ‚îÄ‚îÄ
    (function() {
        const ui = document.getElementById('transform-ui');
        const header = document.getElementById('transform-ui-header');
        if (!ui || !header) return;

        let dragging = false, startX = 0, startY = 0, origLeft = 0, origTop = 0;

        header.addEventListener('mousedown', function(e) {
            if (e.target.tagName === 'BUTTON') return;
            e.preventDefault();
            dragging = true;

            // First time: pin to current screen position, remove centering transform
            if (ui.style.transform !== 'none') {
                const rect = ui.getBoundingClientRect();
                ui.style.left = rect.left + 'px';
                ui.style.top  = rect.top  + 'px';
                ui.style.bottom = 'auto';
                ui.style.transform = 'none';
            }

            startX = e.clientX;
            startY = e.clientY;
            origLeft = parseInt(ui.style.left) || 0;
            origTop  = parseInt(ui.style.top)  || 0;

            header.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', function(e) {
            if (!dragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            ui.style.left = (origLeft + dx) + 'px';
            ui.style.top  = (origTop  + dy) + 'px';
        });

        document.addEventListener('mouseup', function() {
            if (!dragging) return;
            dragging = false;
            header.style.cursor = 'grab';
        });
    })();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // VIEWPORT ZOOM + PAN ENGINE
    // - Mouse wheel: zoom centered on cursor
    // - Middle mouse drag: pan
    // - Space + left-drag: pan
    // - Ctrl+0: reset, Ctrl+= zoom in, Ctrl+- zoom out
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    (function() {
        const vp   = document.getElementById('viewport');
        const cc   = document.getElementById('canvas-container');
        const hud  = document.getElementById('zoom-hud');
        const pct  = document.getElementById('zoom-pct');

        let scale  = 1;
        let ox = 0, oy = 0;   // pan offset in px
        let hudTimer = null;
        let isSpaceDown = false;
        let isPanning = false;
        let panStartX = 0, panStartY = 0;
        let panOriginX = 0, panOriginY = 0;

        function applyTransform() {
            cc.style.transform = 'translate(' + ox + 'px,' + oy + 'px) scale(' + scale + ')';
        }

        function showHud() {
            pct.innerText = Math.round(scale * 100) + '%';
            hud.classList.add('visible');
            clearTimeout(hudTimer);
            hudTimer = setTimeout(() => hud.classList.remove('visible'), 1600);
        }

        window.vpResetZoom = function() {
            scale = 1; ox = 0; oy = 0;
            applyTransform();
            showHud();
        };

        // ‚îÄ‚îÄ Mouse Wheel: zoom centered on cursor ‚îÄ‚îÄ
        vp.addEventListener('wheel', function(e) {
            e.preventDefault();
            const rect = vp.getBoundingClientRect();
            // Cursor position relative to viewport center
            const cx = e.clientX - rect.left - rect.width / 2;
            const cy = e.clientY - rect.top  - rect.height / 2;

            const delta  = e.deltaY < 0 ? 1 : -1;
            const factor = e.ctrlKey ? 0.05 : 0.12;  // pinch-zoom vs wheel
            const newScale = Math.min(8, Math.max(0.08, scale * (1 + delta * factor)));
            const ratio    = newScale / scale;

            // Zoom toward cursor: adjust offset so point under cursor stays fixed
            ox = cx + (ox - cx) * ratio;
            oy = cy + (oy - cy) * ratio;
            scale = newScale;
            applyTransform();
            showHud();
        }, { passive: false });

        // ‚îÄ‚îÄ Middle-mouse drag to pan ‚îÄ‚îÄ
        vp.addEventListener('mousedown', function(e) {
            // Middle mouse (button 1) OR Space+left (button 0)
            const isMiddle = e.button === 1;
            const isSpaceDrag = e.button === 0 && isSpaceDown;
            if (!isMiddle && !isSpaceDrag) return;
            e.preventDefault();
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            panOriginX = ox;
            panOriginY = oy;
            vp.classList.add('panning');
        });

        window.addEventListener('mousemove', function(e) {
            if (!isPanning) return;
            ox = panOriginX + (e.clientX - panStartX);
            oy = panOriginY + (e.clientY - panStartY);
            applyTransform();
        });

        window.addEventListener('mouseup', function(e) {
            if (isPanning) {
                isPanning = false;
                vp.classList.remove('panning');
            }
        });

        // ‚îÄ‚îÄ Space key: switch to pan mode ‚îÄ‚îÄ
        window.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && !e.target.matches('input,textarea,[contenteditable]')) {
                e.preventDefault();
                if (!isSpaceDown) {
                    isSpaceDown = true;
                    vp.style.cursor = 'grab';
                }
            }
            // Ctrl+0 reset, Ctrl+= zoom in, Ctrl+- zoom out
            if (e.ctrlKey || e.metaKey) {
                if (e.key === '0') { e.preventDefault(); vpResetZoom(); }
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    scale = Math.min(8, scale * 1.15);
                    applyTransform(); showHud();
                }
                if (e.key === '-') {
                    e.preventDefault();
                    scale = Math.max(0.08, scale / 1.15);
                    applyTransform(); showHud();
                }
            }
        });
        window.addEventListener('keyup', function(e) {
            if (e.code === 'Space') {
                isSpaceDown = false;
                isPanning = false;
                vp.classList.remove('panning');
                vp.style.cursor = '';
            }
        });

        // ‚îÄ‚îÄ Prevent browser default Ctrl+scroll zoom ‚îÄ‚îÄ
        document.addEventListener('wheel', function(e) {
            if (e.ctrlKey) e.preventDefault();
        }, { passive: false });

    })();

    </script>

<!-- ‚îÄ‚îÄ iOS-style Float Toolbar ‚îÄ‚îÄ -->
<div id="ftb-pill">
    <div id="ftb-bar">
        <!-- Panel floats above bar via position:absolute -->
        <div id="ftb-panel">
            <div class="ftb-panel-row">
                <button class="ftb-p-btn" id="ftb-bold"      onclick="ftbToggle('bold')"        ><b>B</b></button>
                <button class="ftb-p-btn" id="ftb-italic"    onclick="ftbToggle('italic')"      ><i>I</i></button>
                <button class="ftb-p-btn" id="ftb-underline" onclick="ftbToggle('underline')"   ><u>U</u></button>
                <button class="ftb-p-btn" id="ftb-strike"    onclick="ftbToggle('strikethrough')"><s>S</s></button>
                <div id="ftb-color-btn" onclick="document.getElementById('ftb-color-input').click()" title="Text color"></div>
                <input type="color" id="ftb-color-input" value="#000000" oninput="ftbColor(this.value)" onchange="ftbColor(this.value)">
            </div>
            <div class="ftb-size-row">
                <button class="ftb-size-btn" onclick="ftbSize(-2)">‚àí</button>
                <div class="ftb-size-num" id="ftb-size-display">28</div>
                <button class="ftb-size-btn" onclick="ftbSize(+2)">+</button>
            </div>
            <div class="ftb-panel-row">
                <select class="ftb-font-select" id="ftb-font-select" onchange="ftbFont(this.value)">
                    <option value="'Inter', sans-serif">Inter</option>
                    <option value="'Bangers', cursive">Bangers</option>
                    <option value="'Comic Neue', cursive">Comic Neue</option>
                    <option value="'Kalam', cursive">Kalam</option>
                    <option value="'Permanent Marker', cursive">Permanent Marker</option>
                    <option value="'Creepster', cursive">Creepster</option>
                    <option value="'Luckiest Guy', cursive">Luckiest Guy</option>
                    <option value="'Orbitron', sans-serif">Orbitron</option>
                    <option value="'Rock Salt', cursive">Rock Salt</option>
                    <option value="'Special Elite', cursive">Special Elite</option>
                    <option value="'Fredoka One', cursive">Fredoka One</option>
                    <option value="'Boogaloo', cursive">Boogaloo</option>
                    <option value="'Anton', sans-serif">Anton</option>
                    <option value="'Chewy', cursive">Chewy</option>
                    <option value="'Gloria Hallelujah', cursive">Gloria Hallelujah</option>
                    <option value="'Shadows Into Light', cursive">Shadows Into Light</option>
                    <option value="'Caveat', cursive">Caveat</option>
                    <option value="'Pacifico', cursive">Pacifico</option>
                    <option value="'Abril Fatface', cursive">Abril Fatface</option>
                    <option value="'Lilita One', cursive">Lilita One</option>
                    <option value="'Audiowide', sans-serif">Audiowide</option>
                    <option value="'Russo One', sans-serif">Russo One</option>
                    <option value="'Black Ops One', cursive">Black Ops One</option>
                    <option value="'Satisfy', cursive">Satisfy</option>
                    <option value="'Dancing Script', cursive">Dancing Script</option>
                    <option value="'Bebas Neue', cursive">Bebas Neue</option>
                    <option value="'Alfa Slab One', cursive">Alfa Slab One</option>
                </select>
            </div>
            <div class="ftb-panel-row">
                <button class="ftb-align-btn active" id="ftb-al-left"   onclick="ftbAlign('left')"  >&#9776;</button>
                <button class="ftb-align-btn"        id="ftb-al-center" onclick="ftbAlign('center')">&#8801;</button>
                <button class="ftb-align-btn"        id="ftb-al-right"  onclick="ftbAlign('right')" >&#8800;</button>
            </div>
            <div style="text-align:center;font-size:10px;color:#555;font-family:'Inter',sans-serif;">Tap ‚Ä¢‚Ä¢‚Ä¢ to edit text</div>
        </div>
        <!-- Caret between panel and bar -->
        <div id="ftb-caret" style="display:none;"></div>

        <!-- Pill buttons -->
        <button class="ftb-pill-btn" id="ftb-aa-btn" onclick="ftbTogglePanel()" title="Text style">
            <span id="ftb-dot" style="width:14px;height:14px;border-radius:50%;background:#000;display:inline-block;flex-shrink:0;"></span>
            <span style="font-weight:700;font-size:15px;">Aa</span>
        </button>
        <div class="ftb-pill-sep"></div>
        <button class="ftb-pill-btn" onclick="ftbDuplicate()" title="Duplicate">‚ßâ</button>
        <button class="ftb-pill-btn" onclick="ftbDelete()" style="color:#ff453a;" title="Delete">üóë</button>
        <div class="ftb-pill-sep"></div>
        <button class="ftb-pill-btn" onclick="ftbMore()" title="Edit text">‚Ä¢‚Ä¢‚Ä¢</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ Bubble Picker Modal ‚îÄ‚îÄ -->
<div id="bubble-picker-modal" class="overlay-full" style="z-index:4000;">
    <div class="modal-content" style="max-width:440px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;">
            <h2 style="margin:0;font-size:18px;" id="bubble-picker-title">Choose Bubble Style</h2>
            <button onclick="closeBubblePicker()" style="background:none;border:none;color:#666;font-size:22px;cursor:pointer;line-height:1;">‚úï</button>
        </div>
        <div id="bubble-style-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:20px;"></div>
        <input id="bubble-picker-text" class="pub-input" placeholder="Enter text..." style="margin-bottom:12px;">
        <button onclick="confirmBubblePicker()" style="width:100%;padding:13px;background:var(--accent);color:#000;border:none;border-radius:12px;font-weight:900;font-size:14px;cursor:pointer;">Add Bubble ‚Üµ</button>
    </div>
</div>

<!-- ‚îÄ‚îÄ Export Modal ‚îÄ‚îÄ -->
<div id="export-modal" class="overlay-full">
    <div class="modal-content">
        <h2 style="margin-top:0; color:var(--teal);">Export Comic</h2>

        <div class="export-tab-row">
            <button class="export-tab active" onclick="switchExportTab('gif')">üéû GIF</button>
            <button class="export-tab"        onclick="switchExportTab('strip')">üñº Comic Strip</button>
        </div>

        <!-- GIF section -->
        <div id="export-gif" class="export-section active">
            <div class="export-row">
                <span>Frame Speed (FPS)</span>
                <div style="display:flex; align-items:center; gap:8px;">
                    <input type="range" id="gif-fps" min="1" max="24" value="6" oninput="document.getElementById('gif-fps-val').innerText=this.value+'fps'">
                    <span class="val" id="gif-fps-val">6fps</span>
                </div>
            </div>
            <div class="export-row">
                <span>Quality</span>
                <select id="gif-quality" style="background:#1a1a1a; border:1px solid var(--border); color:var(--text); padding:6px 10px; border-radius:8px; font-size:12px;">
                    <option value="10">Fast (lower)</option>
                    <option value="5" selected>Balanced</option>
                    <option value="1">Best (slower)</option>
                </select>
            </div>
            <div class="export-progress" id="gif-progress-bar">
                <div class="export-progress-fill" id="gif-progress-fill"></div>
            </div>
            <div class="export-status" id="gif-status"></div>
            <button id="gif-export-btn" onclick="exportGIF()" style="background:var(--teal); color:#000; border:none; padding:13px; border-radius:12px; font-weight:900; cursor:pointer; font-size:14px;">GENERATE GIF</button>
        </div>

        <!-- Comic Strip section -->
        <div id="export-strip" class="export-section">
            <div style="font-size:12px; color:var(--secondary); line-height:1.6;">
                Exports all frames as a horizontal comic strip image with a <b style="color:var(--text);">ComicCore</b> watermark on the right side.
            </div>
            <div class="export-row">
                <span>Frames per row</span>
                <select id="strip-cols" style="background:#1a1a1a; border:1px solid var(--border); color:var(--text); padding:6px 10px; border-radius:8px; font-size:12px;">
                    <option value="3">3 per row</option>
                    <option value="6" selected>6 per row</option>
                    <option value="9">9 per row</option>
                </select>
            </div>
            <div class="export-status" id="strip-status"></div>
            <button id="strip-export-btn" onclick="exportStrip()" style="background:var(--teal); color:#000; border:none; padding:13px; border-radius:12px; font-weight:900; cursor:pointer; font-size:14px;">SAVE STRIP</button>
        </div>

        <button onclick="closeExportModal()" style="width:100%; margin-top:12px; padding:12px; background:#222; color:#aaa; border:none; border-radius:12px; font-weight:700; cursor:pointer;">Cancel</button>
    </div>
</div>


<!-- ‚îÄ‚îÄ Move BG Modal ‚îÄ‚îÄ -->
<div id="move-bg-modal" style="display:none;">
    <div id="move-bg-modal-header">
        <h3>‚úã MOVE BACKGROUND</h3>
        <div style="display:flex;gap:10px;align-items:center;">
            <button id="move-bg-reset" onclick="resetMoveBg()">Reset</button>
            <button id="move-bg-done" onclick="closeMoveBgModal()">Done ‚úì</button>
            <button id="move-bg-modal-close" onclick="closeMoveBgModal()">‚úï</button>
        </div>
    </div>
    <div id="move-bg-viewport">
        <div id="move-bg-frame">
            <div id="move-bg-frame-inner"></div>
            <div id="move-bg-hint">‚úã Drag to pan ‚Ä¢ or use inputs below</div>
        </div>
    </div>
    <div id="move-bg-controls">
        <div class="move-bg-row">
            <label>X</label>
            <input type="range" id="mbg-x-range" min="-50" max="50" value="0" oninput="onMoveBgInput('x', this.value)">
            <input type="number" class="move-bg-num" id="mbg-x-num" min="-50" max="50" value="0" oninput="onMoveBgInput('x', this.value)">
        </div>
        <div class="move-bg-row">
            <label>Y</label>
            <input type="range" id="mbg-y-range" min="-50" max="50" value="0" oninput="onMoveBgInput('y', this.value)">
            <input type="number" class="move-bg-num" id="mbg-y-num" min="-50" max="50" value="0" oninput="onMoveBgInput('y', this.value)">
        </div>
    </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MOVE BG MODAL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
(function() {
    let mbgX = 0, mbgY = 0;
    let dragging = false, startMX = 0, startMY = 0, startBX = 0, startBY = 0;
    const SENS = 0.25; // units per pixel ‚Äî higher = faster pan

    function clamp(v, mn, mx) { return Math.max(mn, Math.min(mx, Math.round(v))); }

    function syncMoveBgFrame() {
        const el = document.getElementById('move-bg-frame-inner');
        if (!el) return;
        el.style.backgroundPosition = (50 + mbgX) + '% ' + (50 + mbgY) + '%';
        // sync range + number inputs
        document.getElementById('mbg-x-range').value = mbgX;
        document.getElementById('mbg-x-num').value   = mbgX;
        document.getElementById('mbg-y-range').value = mbgY;
        document.getElementById('mbg-y-num').value   = mbgY;
    }

    function commitMoveBg() {
        // Write back into the real bg-x/bg-y and call applyBgTransform
        document.getElementById('bg-x').value     = mbgX;
        document.getElementById('bg-x-num').value = mbgX;
        document.getElementById('bg-y').value     = mbgY;
        document.getElementById('bg-y-num').value = mbgY;
        applyBgTransform();
    }

    window.openMoveBgModal = function() {
        const f = frames[currentIdx];
        if (!f || !f.background || f.background === '#ffffff') {
            alert('Add a background image first!'); return;
        }
        // Hide bg panel while modal is open
        document.getElementById('bg-edit-panel').style.display = 'none';
        document.getElementById('bg-drag-overlay').style.display = 'none';
        const s = f.bgSettings || {};
        mbgX = s.x ?? 0;
        mbgY = s.y ?? 0;

        // Mirror bg into the preview frame
        const inner = document.getElementById('move-bg-frame-inner');
        const scale = s.scale ?? 100;
        const rotate = s.rotate ?? 0;
        inner.style.backgroundImage = '';
        inner.style.background = '';
        inner.style.transform = `scale(${scale/100}) rotate(${rotate}deg)`;
        inner.style.transformOrigin = 'center center';

        if (f.background.startsWith('data:') || f.background.startsWith('http') || f.background.startsWith('blob:')) {
            inner.style.backgroundImage = `url('${f.background}')`;
            inner.style.backgroundSize = 'cover';
            inner.style.backgroundRepeat = 'no-repeat';
        } else {
            inner.style.background = f.background;
            inner.style.backgroundSize = 'cover';
        }

        syncMoveBgFrame();

        const hint = document.getElementById('move-bg-hint');
        hint.style.opacity = '1';
        setTimeout(() => { hint.style.opacity = '0'; }, 2500);

        const modal = document.getElementById('move-bg-modal');
        modal.style.display = 'flex';
        modal.classList.add('open');
    };

    window.closeMoveBgModal = function() {
        commitMoveBg();
        const modal = document.getElementById('move-bg-modal');
        modal.classList.remove('open');
        modal.style.display = 'none';
        // Re-open the bg panel so user can continue editing
        openBgPanel();
    };

    window.resetMoveBg = function() {
        mbgX = 0; mbgY = 0;
        syncMoveBgFrame();
        commitMoveBg();
    };

    window.onMoveBgInput = function(axis, val) {
        const v = clamp(parseFloat(val) || 0, -50, 50);
        if (axis === 'x') mbgX = v; else mbgY = v;
        syncMoveBgFrame();
        commitMoveBg();
    };

    // ‚îÄ‚îÄ Drag to pan ‚îÄ‚îÄ
    document.addEventListener('DOMContentLoaded', function() {
        const frame = document.getElementById('move-bg-frame');
        if (!frame) return;

        frame.addEventListener('mousedown', function(e) {
            if (e.button !== 0) return;
            dragging = true;
            startMX = e.clientX; startMY = e.clientY;
            startBX = mbgX; startBY = mbgY;
            frame.classList.add('dragging');
            e.preventDefault();
        });

        frame.addEventListener('touchstart', function(e) {
            dragging = true;
            startMX = e.touches[0].clientX; startMY = e.touches[0].clientY;
            startBX = mbgX; startBY = mbgY;
            frame.classList.add('dragging');
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('mousemove', function(e) {
            if (!dragging) return;
            mbgX = clamp(startBX + (e.clientX - startMX) * SENS, -50, 50);
            mbgY = clamp(startBY + (e.clientY - startMY) * SENS, -50, 50);
            syncMoveBgFrame();
            commitMoveBg();
        });

        document.addEventListener('touchmove', function(e) {
            if (!dragging) return;
            mbgX = clamp(startBX + (e.touches[0].clientX - startMX) * SENS, -50, 50);
            mbgY = clamp(startBY + (e.touches[0].clientY - startMY) * SENS, -50, 50);
            syncMoveBgFrame();
            commitMoveBg();
        }, { passive: true });

        function endDrag() {
            if (!dragging) return;
            dragging = false;
            frame.classList.remove('dragging');
        }
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);

        // Escape key closes modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('move-bg-modal');
                if (modal.classList.contains('open')) closeMoveBgModal();
            }
        });
    });
})();
</script>

</body>
</html>